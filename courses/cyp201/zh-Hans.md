---
name: 比特币钱包的内部工作原理
goal: 深入了解支撑比特币钱包的加密原理。
objectives:
  - 定义理解比特币中使用的加密算法所必需的理论概念。
  - 全面理解确定性和分层钱包的构造。
  - 知道如何识别和降低管理钱包相关的风险。
  - 理解哈希函数、加密密钥和数字签名的原理。
---

# 深入比特币钱包的核心

通过我们的CYP201课程，发现确定性和分层比特币钱包的秘密！无论你是常规用户还是希望深入了解的爱好者，这门课程都提供了完全沉浸式的体验，让你了解我们每天都在使用的这些工具的工作原理。

学习哈希函数、数字签名（ECDSA和Schnorr）、助记词短语、加密密钥以及接收地址创建的机制，同时探索高级安全策略。

这次培训不仅会让你具备理解比特币钱包结构的知识，还会准备你深入令人兴奋的密码学世界。

通过清晰的教学法、超过60张解释性图表和具体示例，CYP201将使你能够从A到Z理解你的钱包是如何工作的，让你可以自信地导航比特币宇宙。通过了解HD钱包的功能，今天就掌控你的UTXOs！

+++

# 引言

<partId>32960669-d13a-592f-a053-37f70b997cbf</partId>

## 课程介绍

<chapterId>fb4e8857-ea35-5a8a-ae8a-5300234e0104</chapterId>

欢迎来到CYP201课程，我们将深入探讨HD比特币钱包的工作原理。这门课程是为任何想要了解使用比特币的技术基础的人设计的，无论他们是偶尔的用户、有见识的爱好者还是未来的专家。

这次培训的目标是给你掌握你每天使用的工具的钥匙。HD比特币钱包，作为你用户体验的核心，基于一些有时候复杂的概念，我们将尝试使它们变得易于理解。我们将一起揭开它们的神秘面纱！

在深入探讨比特币钱包的构造和运作细节之前，我们将从几章关于接下来所需了解的加密原语开始。
我们将从加密哈希函数开始，这对钱包和比特币协议本身都至关重要。你将发现它们的主要特性，比特币中使用的特定函数，在更技术性的章节中，你将详细了解哈希函数之王：SHA256的工作原理。
![CYP201](assets/fr/010.webp)

接下来，我们将讨论你每天用来保护你的UTXOs的数字签名算法的运作。比特币使用两种：ECDSA和Schnorr协议。你将学习这些算法背后的哪些数学原语以及它们如何确保交易的安全。

![CYP201](assets/fr/021.webp)

一旦我们对这些加密学元素有了良好的理解，我们将最终进入培训的核心部分：确定性和分层钱包！首先，有一节专门讲述助记词短语，这些12或24个单词的序列允许你创建和恢复你的钱包。你将发现这些单词是如何从熵源生成的，以及它们如何简化比特币的使用。

![CYP201](assets/fr/040.webp)
培训将继续学习BIP39密码短语、种子（不要与助记词混淆）、主链代码和主密钥。我们将详细了解这些元素是什么，它们各自的角色，以及它们是如何计算的。
![CYP201](assets/fr/045.webp)

最后，从主密钥出发，我们将发现加密密钥对是如何以确定性和层次化的方式派生出接收地址的。

![CYP201](assets/fr/056.webp)

这次培训将使您能够自信地使用您的钱包软件，同时增强您识别和缓解风险的技能。准备成为比特币钱包的真正专家吧！

# 哈希函数

<partId>3713fee1-2ec2-512e-9e97-b6da9e4d2f17</partId>

## 哈希函数简介

<chapterId>dba011f5-1805-5a48-ac2b-4bd637c93703</chapterId>

比特币使用的第一种加密算法类型包括哈希函数。它们在协议的不同层面以及比特币钱包内部发挥着至关重要的作用。让我们一起发现哈希函数是什么，以及它在比特币中的用途。

### 哈希的定义和原理

哈希是一个过程，通过加密哈希函数将任意长度的信息转换成固定长度的另一段信息。换句话说，哈希函数接受任意大小的输入，并将其转换成固定大小的指纹，称为“哈希”。
哈希有时也被称为“摘要”、“浓缩物”、“浓缩”或“哈希过的”。

例如，SHA256哈希函数产生一个固定长度为256位的哈希。因此，如果我们使用输入“_PlanB_”，一个任意长度的消息，生成的哈希将是以下256位的指纹：

```text
24f1b93b68026bfc24f5c8265f287b4c940fb1664b0d75053589d7a4f821b688
```

![CYP201](assets/fr/001.webp)

### 哈希函数的特性

这些加密哈希函数具有几个基本特性，使它们在比特币和其他计算机系统的背景下特别有用：

1. 不可逆性（或原像抗性）
2. 抗篡改性（雪崩效应）
3. 抗碰撞性
4. 第二原像抗性

#### 1. 不可逆性（原像抗性）：

不可逆性意味着从输入信息计算哈希是容易的，但反向计算，即从哈希找到输入，几乎是不可能的。这个属性使哈希函数非常适合创建独特的数字指纹，而不会泄露原始信息。这个特性通常被称为单向函数或“_陷阱门函数_”。

在给定的例子中，通过知道输入“_PlanB_”获得哈希`24f1b9…`是简单和快速的。然而，仅通过知道`24f1b9…`找到消息“_PlanB_”是不可能的。

![CYP201](assets/fr/002.webp)

因此，不可能找到一个原像$m$对于哈希$h$使得$h = \text{HASH}(m)$，其中$\text{HASH}$是一个加密哈希函数。

#### 2. 抗篡改性（雪崩效应）

第二个特征是抗篡改性，也称为**雪崩效应**。如果输入消息的微小变化导致输出哈希的根本变化，则观察到哈希函数具有此特性。如果我们回到使用输入“_PlanB_”和SHA256函数的例子，我们已经看到生成的哈希如下：

```text
24f1b93b68026bfc24f5c8265f287b4c940fb1664b0d75053589d7a4f821b688
```

如果我们通过这次使用“_Planb_”对输入进行非常轻微的更改，那么仅仅将大写的“B”改为小写的“b”就完全改变了SHA256输出哈希：

```text
bb038b4503ac5d90e1205788b00f8f314583c5e22f72bec84b8735ba5a36df3f
```

![CYP201](assets/fr/003.webp)

这个属性确保即使是原始消息的微小更改也能立即被检测到，因为它不仅仅改变哈希的一小部分，而是整个哈希。这在各个领域验证消息、软件甚至比特币交易的完整性时都很有意义。

#### 3. 抗碰撞性

第三个特征是抗碰撞性。如果计算上不可能找到两个不同的消息产生相同的函数输出哈希，则哈希函数是抗碰撞的。形式上，很难找到两个不同的消息$m_1$和$m_2$，使得：

$$
\text{HASH}(m_1) = \text{HASH}(m_2)
$$

![CYP201](assets/fr/004.webp)

实际上，由于输入的大小可以大于输出的大小，因此数学上不可避免地存在哈希函数的碰撞。这被称为狄利克雷抽屉原理：如果$n$个对象分布在$m$个抽屉中，且$m < n$，那么至少有一个抽屉将必然包含两个或更多对象。对于哈希函数，这个原理适用，因为可能的消息数量（几乎）是无限的，而可能的哈希数量是有限的（在SHA256的情况下为$2^{256}$）。

因此，这个特征并不意味着哈希函数没有碰撞，而是好的哈希函数使得找到碰撞的概率可以忽略不计。例如，这个特征在SHA-0和SHA-1算法上不再验证，这些算法是SHA-2的前身，已经发现了碰撞。因此，这些函数现在通常不建议使用，并且经常被认为是过时的。对于$n$位的哈希函数，抗碰撞性的顺序是$2^{\frac{n}{2}}$，符合生日攻击的规律。例如，对于SHA256（$n = 256$），找到碰撞的复杂度大约是$2^{128}$次尝试。实际上，这意味着如果通过函数传递$2^{128}$个不同的消息，很可能会找到一个碰撞。

#### 4. 抗二次原像攻击

抗二次原像攻击是哈希函数的另一个重要特征。它指出，给定一个消息$m_1$及其哈希$h$，计算上不可行找到另一个消息$m_2 \neq m_1$，使得：

$$
\text{HASH}(m_1) = \text{HASH}(m_2)
$$

因此，抗二次原像攻击在某种程度上类似于抗碰撞性，除了在这里，攻击更加困难，因为攻击者不能自由选择$m_1$。

![CYP201](assets/fr/005.webp)

### 比特币中哈希函数的应用

比特币中最常用的哈希函数是 **SHA256**（"_安全哈希算法 256 位"_）。它由美国国家安全局（NSA）在 2000 年代初设计，并由国家标准与技术研究院（NIST）标准化，产生一个 256 位的哈希输出。

这个函数在比特币的许多方面都有应用。在协议层面，它参与到工作量证明机制中，在这里它通过双重哈希寻找矿工创建的候选区块头部与难度目标之间的部分碰撞。如果找到这种部分碰撞，候选区块就变得有效，并可以被添加到区块链中。

SHA256 也用于构建默克尔树，这是一种用于记录区块中交易的累加器。这种结构也出现在 Utreexo 协议中，该协议允许减小 UTXO 集的大小。此外，随着 2021 年 Taproot 的引入，SHA256 在 MAST（_默克尔化备选脚本树_）中被利用，它允许仅揭示脚本中实际使用的消费条件，而不公开其他可能的选项。它还用于交易标识符的计算、通过 P2P 网络的数据包传输、电子签名等。最后，这对本次培训特别感兴趣的是，SHA256 在应用层用于构建比特币钱包和地址的派生。

大多数时候，当你在比特币上遇到 SHA256 的使用时，实际上会是一个双重哈希 SHA256，记作 "**HASH256**"，它只是简单地连续两次应用 SHA256：
HASH256(m) = SHA256(SHA256(m))

这种双重哈希的做法增加了一层额外的安全性，以防止某些潜在的攻击，尽管今天单个 SHA256 被认为在密码学上是安全的。

另一个在 Script 语言中可用的哈希函数，用于派生接收地址的是 RIPEMD160 函数。这个函数产生一个 160 位的哈希（因此比 SHA256 短）。它通常与 SHA256 结合形成 HASH160 函数：

$$
\text{HASH160}(m) = \text{RIPEMD160}(\text{SHA256}(m))
$$

这种组合用于生成较短的哈希，特别是在创建某些比特币地址时，这些地址代表密钥或脚本哈希的哈希，以及产生密钥指纹。

最后，仅在应用层面，有时也会使用 SHA512 函数，它间接地在钱包的密钥派生中发挥作用。这个函数与 SHA256 在操作上非常相似；两者都属于同一个 SHA2 家族，但 SHA512 产生的哈希，如其名称所示，是 512 位，与 SHA256 的 256 位相比。我们将在后续章节详细介绍其用途。

现在，你已经了解了接下来所需的关于哈希函数的基本知识。在下一章中，我提议更详细地探索比特币核心功能的工作原理：SHA256。我们将解剖它，以理解它是如何实现我们在这里描述的特性的。下一章相当长且技术性强，但不是跟随培训其余部分的必要条件。因此，如果你觉得难以理解，不用担心，直接跳到更容易访问的下一章。

## SHA256 的内部工作原理

<chapterId>905eb320-f15b-5fb6-8d2d-5bb447337deb</chapterId>
我们之前已经看到，哈希函数拥有一些重要特性，这些特性证明了它们在比特币上的使用是合理的。现在，让我们来检查这些哈希函数的内部机制，这些机制赋予了它们这些属性，为此，我建议我们来详细解析SHA256的运作过程。
SHA256和SHA512函数属于同一个SHA2家族。它们的机制基于一种特定的构造，称为**Merkle-Damgård构造**。RIPEMD160也使用这种相同类型的构造。

作为提醒，我们有一个任意大小的消息作为SHA256的输入，并且我们将通过该函数处理它，以获得一个256位的哈希作为输出。

### 输入的预处理

首先，我们需要准备我们的输入消息$m$，使其具有标准长度，这个长度是512位的倍数。这一步对于算法后续的正确运行至关重要。
为此，我们从添加填充位步骤开始。我们首先向消息中添加一个分隔位`1`，然后跟随一定数量的`0`位。添加的`0`位数量是这样计算的，以确保在此添加之后的消息总长度对512取模等于448。因此，消息与填充位的长度$L$等于：

$$
L \equiv 448 \mod 512
$$

$\text{mod}$，代表模运算，是一种数学操作，它在两个整数之间返回欧几里得除法的第一个数除以第二个数的余数。例如：$16 \mod 5 = 1$。这是密码学中广泛使用的一种操作。

这里，填充步骤确保，在下一步添加64位之后，等化消息的总长度将是512位的倍数。如果初始消息的长度为$M$位，那么要添加的`0`位数（$N$）则为：

$$
N = (448 - (M + 1) \mod 512) \mod 512
$$

例如，如果初始消息是950位，计算如下：

$$
\begin{align*}
M & = 950 \\
M + 1 & = 951 \\
(M + 1) \mod 512 & = 951 \mod 512 \\
& = 951 - 512 \cdot \left\lfloor \frac{951}{512} \right\rfloor \\
& = 951 - 512 \cdot 1 \\
& = 951 - 512 \\
& = 439 \\
\\
448 - (M + 1) \mod 512 & = 448 - 439 \\
& = 9 \\
\\
N & = (448 - (M + 1) \mod 512) \mod 512 \\
N & = 9 \mod 512 \\
& = 9
\end{align*}
$$

因此，除了分隔符`1`之外，我们还会有9个`0`。我们要直接在消息$M$之后添加的填充位将是：

```text
1000 0000 00
```

在向我们的消息$M$添加填充位之后，我们还添加一个64位的原始消息长度$M$的二进制表示。这使得哈希函数对位的顺序和消息的长度敏感。
如果我们回到最初的例子，一个初始消息为950比特，我们将十进制数`950`转换为二进制，得到`1110 1101 10`。我们在底部用零填充这个数字，使总数达到64比特。在我们的例子中，这样得到：

```text
0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0011 1011 0110
```

这种填充大小是在位填充之后添加的。因此，我们预处理后的消息由三部分组成：

1. 原始消息$M$；
2. 一个`1`比特后跟着若干个`0`比特，形成位填充；
3. 一个64比特表示的$M$的长度，形成带大小的填充。

![CYP201](assets/fr/006.webp)

### 变量的初始化

SHA256使用八个初始状态变量，记为$A$到$H$，每个都是32比特。这些变量用特定的常数初始化，这些常数是前八个质数的平方根的小数部分。我们将在散列过程中随后使用这些值：

- $A = 0x6a09e667$
- $B = 0xbb67ae85$
- $C = 0x3c6ef372$
- $D = 0xa54ff53a$
- $E = 0x510e527f$
- $F = 0x9b05688c$
- $G = 0x1f83d9ab$
- $H = 0x5be0cd19$

SHA256还使用另外64个常数，记为$K_0$到$K_{63}$，这些是前64个质数的立方根的小数部分：

$$
K[0 \ldots 63] = \begin{pmatrix}
0x428a2f98, & 0x71374491, & 0xb5c0fbcf, & 0xe9b5dba5, \\
0x3956c25b, & 0x59f111f1, & 0x923f82a4, & 0xab1c5ed5, \\
0xd807aa98, & 0x12835b01, & 0x243185be, & 0x550c7dc3, \\
0x72be5d74, & 0x80deb1fe, & 0x9bdc06a7, & 0xc19bf174, \\
0xe49b69c1, & 0xefbe4786, & 0x0fc19dc6, & 0x240ca1cc, \\
0x2de92c6f, & 0x4a7484aa, & 0x5cb0a9dc, & 0x76f988da, \\
0x983e5152, & 0xa831c66d, & 0xb00327c8, & 0xbf597fc7, \\
0xc6e00bf3, & 0xd5a79147, & 0x06ca6351, & 0x14292967, \\
0x27b70a85, & 0x2e1b2138, & 0x4d2c6dfc, & 0x53380d13, \\
0x650a7354, & 0x766a0abb, & 0x81c2c92e, & 0x92722c85, \\
0xa2bfe8a1, & 0xa81a664b, & 0xc24b8b70, & 0xc76c51a3, \\
0xd192e819, & 0xd6990624, & 0xf40e3585, & 0x106aa070, \\
0x19a4c116, & 0x1e376c08, & 0x2748774c, & 0x34b0bcb5, \\
0x391c0cb3, & 0x4ed8aa4a, & 0x5b9cca4f, & 0x682e6ff3, \\
0x748f82ee, & 0x78a5636f, & 0x84c87814, & 0x8cc70208, \\
0x90befffa, & 0xa4506ceb, & 0xbef9a3f7, & 0xc67178f2
\end{pmatrix}
$$


### 输入的划分

现在我们已经平衡了输入，我们将继续进行SHA256算法的主要处理阶段：压缩函数。这一步非常重要，因为它主要赋予了我们在前一章中学习的哈希函数其密码学属性。

首先，我们开始将我们的平衡消息（预处理步骤的结果）划分为每个512位的几个块$P$。如果我们的平衡消息总大小为$n \times 512$位，那么我们将有$n$个块，每个块512位。每个512位块将被压缩函数单独处理，该函数由64轮连续操作组成。让我们将这些块命名为$P_1$、$P_2$、$P_3$...

### 逻辑操作

在详细探索压缩函数之前，了解其中使用的基本逻辑操作是很重要的。这些基于布尔代数的操作在位级别上操作。使用的基本逻辑操作有：

- **合取（AND）**：表示为$\land$，对应逻辑“与”。
- **析取（OR）**：表示为$\lor$，对应逻辑“或”。
- **否定（NOT）**：表示为$\lnot$，对应逻辑“非”。

从这些基本操作中，我们可以定义更复杂的操作，如“异或”（XOR）表示为$\oplus$，在密码学中广泛使用。
每个逻辑操作都可以通过真值表来表示，该表指出了所有可能的二进制输入值组合（两个操作数$p$和$q$）的结果。
对于XOR（$\oplus$）：

| $p$ | $q$ | $p \oplus q$ |
| --- | --- | ------------ |
| 0   | 0   | 0            |
| 0   | 1   | 1            |
| 1   | 0   | 1            |
| 1   | 1   | 0            |

对于AND（$\land$）：

| $p$ | $q$ | $p \land q$ |
| --- | --- | ----------- |
| 0   | 0   | 0           |
| 0   | 1   | 0           |
| 1   | 0   | 0           |
| 1   | 1   | 1           |
NOT ($\lnot p$) :

| $p$ | $\lnot p$ |
| --- | --------- |
| 0   | 1         |
| 1   | 0         |

为了理解位级别上的异或（XOR）操作，我们来看一个例子。如果我们有两个六位的二进制数：

- $a = 101100$
- $b = 001000$

那么：

$$
a \oplus b = 101100 \oplus 001000 = 100100
$$

通过逐位应用XOR操作：

| 位位置 | $a$ | $b$ | $a \oplus b$ |
| ------ | --- | --- | ------------ |
| 1      | 1   | 0   | 1            |
| 2      | 0   | 0   | 0            |
| 3      | 1   | 1   | 0            |
| 4      | 1   | 0   | 1            |
| 5      | 0   | 0   | 0            |
| 6      | 0   | 0   | 0            |

因此，结果是 $100100$。

除了逻辑操作外，压缩函数还使用位移操作，这在算法中的位扩散中将发挥重要作用。

首先，有逻辑右移操作，表示为 $ShR_n(x)$，它将 $x$ 的所有位向右移动 $n$ 个位置，用零填充左侧的空位。

例如，对于 $x = 101100001$（9位）和 $n = 4$：

$$
ShR_4(101100001) = 000010110
$$

从图示上看，右移操作可以这样表示：

![CYP201](assets/fr/007.webp)
SHA256中用于位操作的另一种操作是右循环旋转，表示为 $RotR_n(x)$，它将 $x$ 的位向右移动 $n$ 个位置，将移动出去的位重新插入到字符串的开头。
例如，对于 $x = 101100001$（9位）和 $n = 4$：

$$
RotR_4(101100001) = 000110110
$$

从图示上看，右循环移位操作可以这样表示：

![CYP201](assets/fr/008.webp)

### 压缩函数

现在我们已经理解了基本操作，让我们详细检查SHA256压缩函数。

在前一步中，我们将输入分成了几个512位的片段 $P$。对于每个512位块 $P$，我们有：

- **消息字 $W_i$**：对于 $i$ 从0到63。
- **常数 $K_i$**：对于 $i$ 从0到63，在前一步中定义。
- **状态变量 $A, B, C, D, E, F, G, H$**：用前一步的值初始化。
  首先16个字，$W_0$到$W_{15}$，是直接从处理过的512位块$P$中提取的。每个字$W_i$由块中连续的32位组成。例如，我们取我们的第一部分输入$P_1$，然后我们将其进一步划分为我们称之为字的更小的32位片段。
  接下来的48个字（$W_{16}$到$W_{63}$）使用以下公式生成：

$$
W_i = W_{i-16} + \sigma_0(W_{i-15}) + W_{i-7} + \sigma_1(W_{i-2}) \mod 2^{32}
$$

其中：

- $\sigma_0(x) = RotR_7(x) \oplus RotR_{18}(x) \oplus ShR_3(x)$
- $\sigma_1(x) = RotR_{17}(x) \oplus RotR_{19}(x) \oplus ShR_{10}(x)$

在这种情况下，$x$等于$\sigma_0(x)$的$W_{i-15}$和$\sigma_1(x)$的$W_{i-2}$。

一旦我们确定了我们的512位片段的所有字$W_i$，我们可以继续进行压缩函数，该函数包括执行64轮。

![CYP201](assets/fr/009.webp)
对于从0到63的每一轮$i$，我们有三种不同类型的输入。首先，我们刚刚确定的$W_i$，部分由我们的消息片段$P_n$组成。接下来，是64个常数$K_i$。最后，我们使用状态变量$A$、$B$、$C$、$D$、$E$、$F$、$G$和$H$，这些变量将在哈希过程中发展，并在每个压缩函数中被修改。然而，对于第一部分$P_1$，我们使用之前给出的初始常数。
然后我们对我们的输入执行以下操作：

- **函数$\Sigma_0$：**

$$
\Sigma_0(A) = RotR_2(A) \oplus RotR_{13}(A) \oplus RotR_{22}(A)
$$

- **函数$\Sigma_1$：**

$$
\Sigma_1(E) = RotR_6(E) \oplus RotR_{11}(E) \oplus RotR_{25}(E)
$$

- **函数$Ch$（"_选择_"）：**

$$
Ch(E, F, G) = (E \land F) \oplus (\lnot E \land G)
$$

- **函数$Maj$（"_多数_"）：**

$$
Maj(A, B, C) = (A \land B) \oplus (A \land C) \oplus (B \land C)
$$

然后我们计算2个临时变量：

- $temp1$：

$$
temp1 = H + \Sigma_1(E) + Ch(E, F, G) + K_i + W_i \mod 2^{32}
$$

- $temp2$：

$$
temp2 = \Sigma_0(A) + Maj(A, B, C) \mod 2^{32}
$$

接下来，我们按如下方式更新状态变量：

$$
\begin{cases}
H = G \\
G = F \\
F = E \\
E = D + temp1 \mod 2^{32} \\
D = C \\
C = B \\
B = A \\
A = temp1 + temp2 \mod 2^{32}
\end{cases}
$$

以下是SHA256压缩函数一个轮次的表示图，正如我们刚才描述的：

![CYP201](assets/fr/010.webp)

- 箭头表示数据流动；
- 方框代表执行的操作；
- 被$+$包围的表示模$2^{32}$的加法。

我们已经可以观察到，这一轮输出了新的状态变量$A$、$B$、$C$、$D$、$E$、$F$、$G$和$H$。这些新变量将作为下一轮的输入，进而产生新的变量$A$、$B$、$C$、$D$、$E$、$F$、$G$和$H$，用于下一轮。这个过程一直持续到第64轮。
在64轮之后，我们通过将它们与第64轮结束时的最终值相加，来更新状态变量的初始值：

$$
\begin{cases}
A = A_{\text{initial}} + A \mod 2^{32} \\
B = B_{\text{initial}} + B \mod 2^{32} \\
C = C_{\text{initial}} + C \mod 2^{32} \\
D = D_{\text{initial}} + D \mod 2^{32} \\
E = E_{\text{initial}} + E \mod 2^{32} \\
F = F_{\text{initial}} + F \mod 2^{32} \\
G = G_{\text{initial}} + G \mod 2^{32} \\
H = H_{\text{initial}} + H \mod 2^{32}
\end{cases}
$$

这些新的$A$、$B$、$C$、$D$、$E$、$F$、$G$和$H$的值将作为下一个区块$P_2$的初始值。对于这个区块$P_2$，我们复制相同的压缩过程，进行64轮，然后我们更新区块$P_3$的变量，依此类推，直到我们的输入的最后一个区块。

在处理完所有消息区块后，我们将变量$A$、$B$、$C$、$D$、$E$、$F$、$G$和$H$的最终值连接起来，形成我们哈希函数的最终256位哈希值：


$$

\text{哈希} = A \Vert B \Vert C \Vert D \Vert E \Vert F \Vert G \Vert H

$$

每个变量是一个32位整数，所以它们的连接总是产生一个256位的结果，无论我们对哈希函数的消息输入的大小如何。

### 加密属性的理由

但是，这个函数是如何做到不可逆、抗碰撞和抗篡改的呢？

对于抗篡改，很容易理解。进行了如此多的级联计算，这些计算既依赖于输入也依赖于常数，以至于初始消息的最轻微修改都会完全改变所走的路径，从而完全改变输出哈希。这就是所谓的雪崩效应。这个属性部分是通过将中间状态与每个部分的初始状态混合来确保的。
接下来，当讨论加密哈希函数时，通常不使用“不可逆性”这一术语。相反，我们讨论的是“原像抗性”，它指的是对于任何给定的$y$，很难找到一个$x$使得$h(x) = y$。这种原像抗性是通过压缩函数中执行的操作的代数复杂性和强非线性以及过程中某些信息的丢失来保证的。例如，对于给定的模加运算结果，存在多个可能的操作数：$$
3+2 \mod 10 = 5 \\
7+8 \mod 10 = 5 \\
5+10 \mod 10 = 5
$$

在这个例子中，仅知道使用的模（10）和结果（5），无法确定使用的正确操作数。可以说，模10有多个同余。

对于XOR操作，我们面临着同样的问题。记住这个操作的真值表：任何1位输出都可以由两种不同的输入配置确定，这两种配置有完全相同的成为正确值的概率。因此，仅通过知道其结果，无法确定XOR的操作数。如果我们增加XOR操作数的大小，仅知道结果的可能输入数量将呈指数级增长。此外，XOR经常与其他位级操作一起使用，例如$\text{RotR}$操作，这增加了结果的可能解释。

压缩函数还使用$\text{ShR}$操作。此操作移除了一部分基本信息，随后无法检索。再次强调，没有代数方法可以逆转此操作。所有这些单向和信息丢失操作在压缩函数中非常频繁地使用。因此，给定输出的可能输入数量几乎是无限的，每次尝试逆向计算都会导致方程中未知数的数量非常高，而且每一步都会呈指数级增长。

最后，对于抗碰撞性的特性，有几个参数发挥作用。原始消息的预处理起着至关重要的作用。如果没有这种预处理，可能更容易在函数上找到碰撞。尽管理论上碰撞存在（由于鸽巢原理），但哈希函数的结构，结合上述属性，使得找到碰撞的概率极低。
对于哈希函数来说，要具备抗碰撞性，至关重要的是：

- 输出是不可预测的：任何可预测性都可以被利用来比暴力攻击更快地找到碰撞。该函数确保输出的每一位都以非平凡的方式依赖于输入。换句话说，该函数设计得使得最终结果的每一位都有独立的概率是0或1，即使这种独立性在实践中并不是绝对的。
- 哈希的分布是伪随机的：这确保了哈希均匀分布。
- 哈希的大小是可观的：结果可能空间越大，找到碰撞就越困难。

密码学家通过评估找到碰撞的最佳可能攻击，然后调整参数使这些攻击无效来设计这些函数。

### Merkle-Damgård 构造

SHA256的结构基于Merkle-Damgård构造，它允许将压缩函数转换为可以处理任意长度消息的哈希函数。这正是我们在本章中看到的。
然而，一些旧的哈希函数，如SHA1或MD5，它们使用这种特定的构造，容易受到长度扩展攻击的影响。这是一种技术，允许攻击者仅知道消息$M$的哈希值和$M$的长度（而不知道消息本身），就能计算出由$M$与额外内容连接形成的消息$M'$的哈希值。
尽管SHA256使用相同类型的构造，理论上它对这种类型的攻击具有抵抗力，不像SHA1和MD5。这可能解释了比特币中由中本聪实施的双重哈希的神秘之处。为了避免这种类型的攻击，中本聪可能更倾向于使用双重SHA256：

$$
\text{HASH256}(m) = \text{SHA256}(\text{SHA256}(m))
$$

这增强了针对可能与Merkle-Damgård构造相关的攻击的安全性，但它并没有提高哈希过程在抗碰撞性方面的安全性。此外，即使SHA256对这种类型的攻击是脆弱的，它也不会产生严重的影响，因为比特币中哈希函数的所有用例都涉及公开数据。然而，长度扩展攻击对攻击者可能只有在哈希数据是私有的，并且用户已将哈希函数作为这些数据的认证机制（类似于MAC）使用时才有用。因此，比特币设计中双重哈希的实施仍是一个谜。
现在我们已经详细查看了哈希函数的工作原理，特别是在比特币中广泛使用的SHA256，我们将更具体地关注在应用层面使用的密码学衍生算法，特别是用于派生钱包密钥的算法。

## 用于衍生的算法

<chapterId>cc668121-7789-5e99-bf5e-1ba085f4f5f2</chapterId>

在比特币的应用层面，除了哈希函数，还使用密码学衍生算法从初始输入生成安全数据。尽管这些算法依赖于哈希函数，但它们服务于不同的目的，特别是在认证和密钥生成方面。这些算法保留了哈希函数的一些特性，如不可逆性、抗篡改性和抗碰撞性。

在比特币钱包上，主要使用2种衍生算法：

1. **HMAC（_基于哈希的消息认证码_）**
2. **PBKDF2（_基于密码的密钥衍生函数2_）**

我们将一起探讨它们各自的功能和作用。

### HMAC-SHA512

HMAC是一种密码学算法，基于哈希函数和一个秘密密钥的组合计算出一个认证码。比特币使用HMAC-SHA512，这是使用SHA512哈希函数的HMAC变体。我们已经在前一章看到，SHA512与SHA256属于同一家族的哈希函数，但它产生一个512位的输出。

以下是其一般操作方案，其中$m$是输入消息，$K$是一个秘密密钥：

![CYP201](assets/fr/011.webp)

让我们更详细地研究这个HMAC-SHA512黑盒子中发生的事情。HMAC-SHA512函数包括：

- $m$：用户选择的任意大小的消息（第一个输入）；
- $K$：用户选择的任意秘密密钥（第二个输入）；
- $K'$：调整到哈希函数块大小$B$（对于SHA512为1024位，或128字节）的密钥$K$；
- $\text{SHA512}$：SHA512哈希函数；
- $\oplus$：XOR（异或）操作；
- $\Vert$：连接运算符，用于将比特串首尾相连；
- $\text{opad}$：由字节$0x5c$重复128次组成的常量；
- $\text{ipad}$：由字节$0x36$重复128次组成的常量；
  在计算HMAC之前，需要根据块大小$B$使密钥和常量相等。例如，如果密钥$K$的长度小于128字节，则用零填充以达到大小$B$。如果$K$的长度超过128字节，则使用SHA512进行压缩，然后添加零直到达到128字节。这样，就获得了一个等化的密钥$K'$。
  通过重复其基础字节（$\text{opad}$的$0x5c$，$\text{ipad}$的$0x36$）直到达到大小$B$，得到$\text{opad}$和$\text{ipad}$的值。因此，对于$B = 128$字节，我们有：

$$
\text{opad} = \underbrace{0x5c5c\ldots5c}_{128 \, \text{bytes}}
$$

一旦完成预处理，HMAC-SHA512算法由以下等式定义：

$$
\text {HMAC-SHA512}_K(m) = \text{SHA512} \left( (K' \oplus \text{opad}) \parallel \text{SHA512} \left( (K' \oplus \text{ipad}) \parallel m \right) \right)
$$

这个等式分解为以下步骤：

1. 将调整后的密钥$K'$与$\text{ipad}$进行异或运算，得到$\text{iKpad}$；
2. 将调整后的密钥$K'$与$\text{opad}$进行异或运算，得到$\text{oKpad}$；
3. 将$\text{iKpad}$与消息$m$连接起来。
4. 使用SHA512对此结果进行哈希处理，得到一个中间哈希$H_1$。
5. 将$\text{oKpad}$与$H_1$连接起来。
6. 使用SHA512对此结果进行哈希处理，得到最终结果$H_2$。

这些步骤可以如下图示概括：

![CYP201](assets/fr/012.webp)

HMAC在比特币中特别用于HD（分层确定性）钱包的密钥派生（我们将在后续章节中详细讨论）以及PBKDF2的组成部分。

### PBKDF2

PBKDF2（_基于密码的密钥派生函数2_）是一种旨在增强密码安全性的密钥派生算法。该算法对密码和一个加密盐应用伪随机函数（这里是HMAC-SHA512），然后重复此操作特定次数以产生输出密钥。

在比特币中，PBKDF2用于从助记词和密码短语生成HD钱包的种子（但我们将在后续章节中详细讨论）。

PBKDF2过程如下，其中：

- $m$：用户的助记词；
- $s$：可选的密码短语以增加安全性（如果没有密码短语则为空字段）；
- $n$：函数的迭代次数，在我们的案例中，它是2048。
  PBKDF2函数是迭代定义的。每次迭代都会取上一次的结果，通过HMAC-SHA512处理，并将连续的结果组合起来产生最终的密钥：
  $$
  \text{PBKDF2}(m, s) = \text{HMAC-SHA512}^{2048}(m, s)
  $$

从图示上看，PBKDF2可以如下表示：

![CYP201](assets/fr/013.webp)

在本章中，我们探讨了HMAC-SHA512和PBKDF2函数，这些函数使用散列函数来确保比特币协议中密钥派生的完整性和安全性。在下一部分，我们将研究数字签名，这是比特币中广泛使用的另一种加密方法。

# 数字签名

<partId>76b58a00-0c18-54b9-870d-6b7e34029db8</partId>

## 数字签名与椭圆曲线

<chapterId>c9dd9672-6da1-57f8-9871-8b28994d4c1a</chapterId>

比特币中使用的第二种加密方法涉及数字签名算法。让我们探索这涉及什么以及它是如何工作的。

### 比特币、UTXO和消费条件

对于初学者来说，比特币中的“_钱包_”一词可能相当令人困惑。实际上，所谓的比特币钱包是一种软件，它并不直接持有你的比特币，不像实体钱包可以持有硬币或纸币。比特币只是一种账户单位。这种账户单位由**UTXO**（_未花费的交易输出_）表示，这些是未花费的交易输出。如果这些输出未被花费，意味着它们属于某个用户。UTXO在某种意义上是属于用户的比特币的碎片，大小不一。

比特币协议是分布式的，无需中央权威即可运作。因此，它不像传统银行记录，你的欧元仅仅与你的个人身份相关联。在比特币上，你的UTXO之所以属于你，是因为它们受到Script语言中指定的消费条件的保护。简单来说，有两种类型的脚本：锁定脚本（_scriptPubKey_），它保护一个UTXO，以及解锁脚本（_scriptSig_），它允许解锁一个UTXO，从而花费它所代表的比特币单位。
比特币最初的操作是使用公钥来锁定资金，在*scriptPubKey*中指定，希望花费此UTXO的人必须提供与此公钥对应的私钥的有效签名。因此，要解锁这个UTXO，就必须在*scriptSig*中提供有效的签名。正如它们的名字所示，公钥是众所周知的，因为它在区块链上广播，而私钥只有资金的合法拥有者知道。
这是比特币的基本操作，但随着时间的推移，这种操作变得更加复杂。首先，中本聪还引入了P2PKH脚本，它在*scriptPubKey*中使用接收地址，该地址代表公钥的哈希。然后，随着SegWit和之后的Taproot的到来，系统变得更加复杂。然而，基本原则仍然基本相同：使用公钥或这个键的表示来锁定UTXO，需要相应的私钥来解锁它们，从而花费它们。
想要进行比特币交易的用户必须使用其私钥对相关交易创建一个数字签名。其他网络参与者可以验证该签名。如果签名有效，这意味着发起交易的用户确实是私钥的拥有者，因此也是他们希望花费的比特币的拥有者。其他用户随后可以接受并传播该交易。
因此，拥有被公钥锁定的比特币的用户必须找到一种安全存储解锁资金所需内容的方法：私钥。比特币钱包正是一种设备，能让你轻松保管所有密钥，而无需让其他人访问它们。因此，它更像是一个钥匙串而不是一个钱包。

公钥和私钥之间的数学联系，以及执行签名以证明私钥拥有权而不泄露它的能力，是通过数字签名算法实现的。在比特币协议中，使用了2种签名算法：**ECDSA**（_椭圆曲线数字签名算法_）和**Schnorr签名方案**。ECDSA是比特币自创立之初就使用的数字签名协议。Schnorr在比特币中较为新近，它是在2021年11月通过Taproot更新引入的。
这两种算法在其机制上非常相似。它们都基于椭圆曲线密码学。这两种协议之间的主要区别在于签名的结构和一些特定的数学属性。因此，我们将研究这些算法的运作，从最古老的ECDSA开始。

### 椭圆曲线密码学

椭圆曲线密码学（ECC）是一组使用椭圆曲线的各种数学和几何属性进行加密的算法。这些算法的安全性依赖于椭圆曲线上离散对数问题的难度。椭圆曲线特别用于密钥交换、非对称加密或创建数字签名。

这些曲线的一个重要属性是它们相对于x轴对称。因此，任何非垂直线在两个不同点切割曲线时，总会在第三点与曲线相交。此外，曲线上任何非奇异点的切线都会在另一点与曲线相交。这些属性对于定义曲线上的操作很有用。

这是在实数域上椭圆曲线的表示：

![CYP201](assets/fr/014.webp)

每个椭圆曲线都由以下形式的方程定义：

$$
y^2 = x^3 + ax + b
$$

### secp256k1

要使用ECDSA或Schnorr，必须选择椭圆曲线的参数，即曲线方程中的$a$和$b$的值。有不同标准的椭圆曲线被认为在密码学上是安全的。最著名的是*NIST*（_国家标准与技术研究院_）定义和推荐的*secp256r1*曲线。

尽管如此，比特币的发明者中本聪选择不使用这个曲线。这个选择的原因不为人知，但有些人认为他更倾向于找到一个替代品，因为这个曲线的参数可能包含后门。相反，比特币协议使用标准的**_secp256k1_**曲线。这个曲线由参数$a = 0$和$b = 7$定义。因此，其方程为：

$$
y^2 = x^3 + 7
$$

其在实数域上的图形表示如下：
![CYP201](assets/fr/015.webp)
然而，在密码学中，我们处理的是有限的数字集合。更具体地说，我们在有限域$\mathbb{F}_p$上工作，这是一个模一个素数$p$的整数域。
**定义**：一个素数是大于或等于2的自然整数，它只有两个不同的正整数除数：1和它自己。例如，数字7是一个素数，因为它只能被1和7整除。另一方面，数字8不是素数，因为它可以被1、2、4和8整除。
在比特币中，用来定义有限域的素数$p$非常大。它的选择方式是使得域的阶（即$\mathbb{F}_p$中的元素数量）足够大，以确保密码学安全。

使用的素数$p$是：

```text
p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
```

在十进制表示中，这对应于：

$$
p = 2^{256} - 2^{32} - 977
$$

因此，我们的椭圆曲线方程实际上是：

$$
y^2 \equiv x^3 + 7 \mod p
$$

鉴于这条曲线是在有限域$\mathbb{F}_p$上定义的，它不再像连续曲线那样，而是一个离散的点集。例如，这里是比特币中使用的曲线在非常小的$p = 17$时的样子：

![CYP201](assets/fr/016.webp)

在这个例子中，我有意将有限域限制在$p = 17$，出于教育原因，但必须想象比特币中使用的那个远远大于$2^{256}$。

我们使用模$p$的整数有限域来确保曲线上操作的准确性。实际上，实数域上的椭圆曲线受到计算计算中舍入误差的影响。如果在曲线上执行大量操作，这些误差会累积，最终结果可能是不正确的或难以复现的。仅使用正整数确保计算的完美准确性，从而确保结果的可复现性。

有限域上椭圆曲线的数学与实数域上的相似，不同之处在于所有操作都是模$p$进行的。为了简化解释，我们将在接下来的章节中继续使用定义在实数上的曲线来阐述概念，同时记住实际上曲线是在有限域上定义的。

如果您希望了解更多关于现代密码学的数学基础，我还推荐咨询Plan ₿ Network上的这门其他课程：

https://planb.network/courses/cyp302

## 从私钥计算公钥

<chapterId>fcb2bd58-5dda-5ecf-bb8f-ad1a0561ab4a</chapterId>
如前所述，比特币上的数字签名算法基于一对数学上相互关联的私钥和公钥。让我们一起探索这种数学联系是什么以及它们是如何生成的。

### 私钥

私钥只是一个随机或伪随机数。在比特币的情况下，这个数字是256位大小。因此，比特币私钥的理论可能数量是$2^{256}$。
**注意**：“伪随机数”是一种具有接近真正随机数属性的数字，但是通过确定性算法生成的。
然而，在实践中，我们的椭圆曲线secp256k1上只有$n$个不同的点，其中$n$是曲线的生成点$G$的阶。我们稍后会看到这个数字对应什么，但只需记住，有效的私钥是一个介于$1$和$n-1$之间的整数，知道$n$是一个接近但略小于$2^{256}$的数字。因此，有一些256位的数字不适合成为比特币的私钥，特别是所有在$n$和$2^{256}$之间的数字。如果随机数（私钥）的生成产生一个值$k$使得$k \geq n$，它被认为是无效的，必须生成一个新的随机值。

因此，比特币私钥的可能性数量大约是$n$，这是一个接近$1.158 \times 10^{77}$的数字。这个数字如此之大，以至于如果你随机选择一个私钥，统计上几乎不可能碰到另一个用户的私钥。为了给你一个规模的概念，比特币上可能的私钥数量的数量级接近于可观测宇宙中估计的原子数量。

正如我们将在接下来的章节中看到的，今天，比特币上使用的大多数私钥不是随机生成的，而是由一个助记词短语确定性派生的结果，它本身是伪随机的（这就是著名的12或24个词的短语）。这一信息对于像ECDSA这样的签名算法的使用并没有改变任何事情，但它有助于我们重新聚焦于比特币的普及。

在解释的后续部分，私钥将用小写字母$k$表示。

### 公钥

公钥是椭圆曲线上的一个点，用大写字母$K$表示，并且是从私钥$k$计算出来的。这个点$K$由椭圆曲线上的一对坐标$(x, y)$表示，每个坐标都是模$p$的整数，$p$是定义有限域$\mathbb{F}_p$的质数。
在实践中，一个未压缩的公钥由512位（或64字节）表示，对应于两个256位的数字（$x$和$y$）首尾相连。这些数字是我们在secp256k1上的点的横坐标（$x$）和纵坐标（$y$）。如果我们加上前缀，公钥总共有520位。

然而，也可以通过只保留我们曲线上点的横坐标$x$和一个指示$y$奇偶性的字节，使用只有33字节（264位）的压缩形式来表示公钥。这就是所谓的压缩公钥。我将在本培训的最后几章更多地讨论这个问题。但你需要记住的是，公钥$K$是由$x$和$y$描述的一个点。

为了计算对应于我们公钥的点$K$，我们使用椭圆曲线上的标量乘法运算，定义为生成点$G$的重复加法（$k$次）：

$$
K = k \cdot G
$$

其中：

- $k$是私钥（一个介于$1$和$n-1$之间的随机整数）；
- $G$ 是比特币网络所有参与者使用的椭圆曲线的生成点；
- $\cdot$ 表示椭圆曲线上的标量乘法，相当于将点 $G$ 自身加 $k$ 次。

这个点 $G$ 对比特币上所有公钥来说是共同的这一事实，使我们能够确信相同的私钥 $k$ 总是会给我们相同的公钥 $K$：

![CYP201](assets/fr/017.webp)

这个操作的主要特点是它是一个单向函数。知道私钥 $k$ 和生成点 $G$，很容易计算出公钥 $K$，但是仅知道公钥 $K$ 和生成点 $G$，几乎不可能计算出私钥 $k$。从 $K$ 和 $G$ 中找到 $k$ 相当于解决椭圆曲线上的离散对数问题，这是一个数学上难以解决的问题，目前没有已知的高效算法。即使是最强大的当前计算器也无法在合理的时间内解决这个问题。

![CYP201](assets/fr/018.webp)

### 椭圆曲线上的点加和点倍

椭圆曲线上的加法概念是几何定义的。如果我们有曲线上的两个点 $P$ 和 $Q$，操作 $P + Q$ 通过画一条通过 $P$ 和 $Q$ 的直线来计算。这条线必然会在第三个点 $R'$ 与曲线相交。然后我们取这个点关于 x 轴的镜像点来获得点 $R$，这是加法的结果：

$$
P + Q = R
$$

图形上，这可以表示为：

![CYP201](assets/fr/019.webp)

对于点的倍增，即操作 $P + P$，我们在点 $P$ 处画曲线的切线。这个切线在另一个点 $S'$ 与曲线相交。然后我们取这个点关于 x 轴的镜像点来获得点 $S$，这是倍增的结果：

$$
2P = S
$$

图形上，这显示为：

![CYP201](assets/fr/020.webp)

通过使用这些加法和倍增操作，我们可以通过执行重复的倍增和加法来执行点乘以整数 $k$ 的标量乘法，记为 $kP$。

例如，假设我们选择了一个私钥 $k = 4$。为了计算关联的公钥，我们执行：

$$
K = k \cdot G = 4G
$$

图形上，这对应于执行一系列的加法和倍增：

- 通过倍增 $G$ 来计算 $2G$。
- 通过倍增 $2G$ 来计算 $4G$。

![CYP201](assets/fr/021.webp)

如果我们希望，例如，计算点 $3G$，我们必须首先通过倍增点 $G$ 来计算点 $2G$，然后加上 $G$ 和 $2G$。为了加上 $G$ 和 $2G$，只需画一条连接这两点的线，找到这条线与椭圆曲线的交点处唯一的点 $-3G$，然后确定 $3G$ 为 $-3G$ 的相反点。

我们将有：

$$
G + G = 2G
$$

$$
2G + G = 3G
$$

图形上，这将表示为：

![CYP201](assets/fr/022.webp)

### 单向函数

多亏了这些操作，我们可以理解为什么从私钥推导出公钥很容易，但反之则几乎不可能。

让我们回到我们的简化示例。使用私钥 $k = 4$。为了计算关联的公钥，我们执行：

$$
K = k \cdot G = 4G
$$

因此，我们能够通过知道 $k$ 和 $G$ 轻松计算出公钥 $K$。

现在，如果有人只知道公钥 $K$，他们面临的是离散对数问题：找到 $k$ 使得 $K = k \cdot G$。这个问题被认为是困难的，因为在椭圆曲线上没有有效的算法来解决它。这确保了ECDSA和Schnorr算法的安全性。

当然，在这个简化的例子中，$k = 4$，通过试错法找到 $k$ 是可能的，因为可能性的数量很低。然而，在比特币实践中，$k$ 是一个256位的整数，使得可能性的数量天文数字般的大（大约 $1.158 \times 10^{77}$）。因此，通过暴力方法找到 $k$ 是不可行的。

## 使用私钥签名

<chapterId>bb07826f-826e-5905-b307-3d82001fb778</chapterId>

现在您知道如何从私钥派生公钥，您已经可以通过使用这对密钥作为支付条件来接收比特币了。但如何花费它们呢？要花费比特币，您需要解锁附加到您的UTXO上的 _scriptPubKey_ 以证明您确实是其合法拥有者。为此，您必须使用最初用于计算 $K$ 的私钥 $k$ 产生一个与 _scriptPubKey_ 中存在的公钥 $K$ 匹配的签名 $s$。因此，数字签名是您拥有与您声称的公钥相关联的私钥的无可辩驳的证明。

### 椭圆曲线参数

要执行数字签名，所有参与者首先必须就使用的椭圆曲线的参数达成一致。就比特币而言，**secp256k1** 的参数如下：

有限域 $\mathbb{Z}_p$ 定义为：

$$
p = 2^{256} - 2^{32} - 977
$$

```text
p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
```

$p$ 是一个略小于 $2^{256}$ 的非常大的质数。

在 $\mathbb{Z}_p$ 上定义的椭圆曲线 $y^2 = x^3 + ax + b$：

$$
a = 0, \quad b = 7
$$

生成点或原点 $G$：

```text
G = 0x0279BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798
```

这个数字是压缩形式，只给出了点 $G$ 的横坐标。开头的 `02` 前缀决定了哪一个具有此横坐标 $x$ 的两个值应当作为生成点使用。
$G$ 的阶 $n$（存在点的数量）和余因子 $h$：

```text
n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141
```

$n$ 是一个非常大的数字，略小于 $p$。

$$
h=1
$$

$h$ 是辅因子或子群的数量。我在这里不会详细讲解它代表什么，因为这相当复杂，在比特币的情况下，我们不需要考虑它，因为它等于 $1$。

所有这些信息都是公开的，所有参与者都知道。多亏了它们，用户能够制作数字签名并验证它。

### 使用ECDSA进行签名

ECDSA算法允许用户使用他们的私钥对消息进行签名，以这样一种方式，任何知道相应公钥的人都可以验证签名的有效性，而无需揭示私钥。在比特币的上下文中，要签名的消息取决于用户选择的 _sighash_。正是这个 _sighash_ 将决定交易的哪些部分被签名覆盖。我将在下一章更多地讨论这个问题。

以下是生成ECDSA签名的步骤：

首先，我们计算需要签名的消息的哈希值（$e$）。因此，消息 $m$ 通过一个加密哈希函数传递，通常是SHA256或在比特币的情况下是双重SHA256：

$$
e = \text{HASH}(m)
$$

接下来，我们计算一个随机数。在密码学中，随机数仅仅是以随机或伪随机方式生成的一次性使用的数字。也就是说，每次用这对密钥制作新的数字签名时，使用不同的随机数非常重要，否则，它将危及私钥的安全。因此，只需确定一个随机且唯一的整数 $r$，使得 $1 \leq r \leq n-1$，其中 $n$ 是椭圆曲线生成点 $G$ 的阶。

然后，我们将计算椭圆曲线上的点 $R$，其坐标为 $(x_R, y_R)$，使得：

$$
R = r \cdot G
$$

我们提取点 $R$ 的横坐标值（$x_R$）。这个值代表签名的第一部分。最后，我们以这种方式计算签名的第二部分 $s$：

$$
s = r^{-1} \left( e + k \cdot x_R \right) \mod n
$$

其中：

- $r^{-1}$ 是 $r$ 模 $n$ 的模逆，即一个整数，使得 $r \cdot r^{-1} \equiv 1 \mod n$；
- $k$ 是用户的私钥；
- $e$ 是消息的哈希值；
- $n$ 是椭圆曲线的生成点 $G$ 的阶。

然后，签名简单地是 $x_R$ 和 $s$ 的连接：

$$
\text{SIG} = x_R \Vert s
$$

### 验证ECDSA签名

要验证签名 $(x_R, s)$，任何知道公钥 $K$ 和椭圆曲线参数的人都可以按照这种方式进行：
首先，验证 $x_R$ 和 $s$ 是否在区间 $[1, n-1]$ 内。这确保了签名遵守椭圆群的数学约束。如果不是这样，验证者会立即将签名视为无效拒绝。
然后，计算消息的哈希值：

$$
e = \text{HASH}(m)
$$

计算 $s$ 模 $n$ 的模逆：

$$
s^{-1} \mod n
$$

以这种方式计算两个标量值 $u_1$ 和 $u_2$：

$$
\begin{align*}
u_1 &= e \cdot s^{-1} \mod n \\
u_2 &= x_R \cdot s^{-1} \mod n
\end{align*}
$$

最后，计算椭圆曲线上的点 $V$，使得：

$$
V = u_1 \cdot G + u_2 \cdot K
$$

只有当 $x_V \equiv x_R \mod n$ 时，签名才有效，其中 $x_V$ 是点 $V$ 的 $x$ 坐标。实际上，通过结合 $u_1 \cdot G$ 和 $u_2 \cdot K$，可以得到一个点 $V$，如果签名有效，必须对应于签名过程中使用的点 $R$（模 $n$）。

### 使用 Schnorr 协议的签名

Schnorr 签名方案是 ECDSA 的一个替代方案，提供了许多优势。自 2021 年引入 Taproot 和 P2TR 脚本模式以来，比特币上就可以使用它。与 ECDSA 一样，Schnorr 方案允许使用私钥对消息进行签名，以便任何知道相应公钥的人都可以验证签名。
在 Schnorr 的情况下，使用与 ECDSA 相同的曲线和相同的参数。然而，与 ECDSA 相比，公钥的表示略有不同。实际上，它们仅由椭圆曲线上点的 $x$ 坐标指定。与 ECDSA 不同，其中压缩公钥由 33 字节表示（前缀字节指示 $y$ 的奇偶性），Schnorr 使用 32 字节的公钥，仅对应于点 $K$ 的 $x$ 坐标，并且默认假设 $y$ 是偶数。这种简化的表示减小了签名的大小，并促进了验证算法中某些优化的实现。
公钥然后是点 $K$ 的 $x$ 坐标：

$$
\text{pk} = K_x
$$

生成签名的第一步是哈希消息。但与 ECDSA 不同，它是与其他值一起完成的，并且使用带标签的哈希函数来避免不同上下文中的冲突。带标签的哈希函数简单地涉及在哈希函数的输入旁边添加一个任意标签以及消息数据。

![CYP201](assets/fr/023.webp)

除了消息之外，公钥的 $x$ 坐标 $K_x$，以及从随机数 $r$ 计算出的点 $R$（$R=r \cdot G$），它本身是每个签名的唯一整数，从私钥和消息中确定性地计算出来，以避免与随机数重用相关的漏洞，也被传递到带标签的函数中。就像公钥一样，只保留随机点 $R_x$ 的 $x$ 坐标来描述点。

这种哈希的结果记为 $e$，称为“挑战”：
e = \text{HASH}(\text{``BIP0340/challenge''}, R_x \Vert K_x \Vert m) \mod n$$

这里，$\text{HASH}$ 是 SHA256 哈希函数，而 $\text{``BIP0340/challenge''}$ 是哈希过程中的特定标签。

最后，参数 $s$ 是根据私钥 $k$、随机数 $r$ 和挑战 $e$ 以这种方式计算出来的：

$$
s = (r + e \cdot k) \mod n
$$

然后，签名就简单地是 $Rx$ 和 $s$ 的对。

$$
\text{SIG} = R_x \Vert s
$$

### Schnorr 签名的验证

验证 Schnorr 签名比验证 ECDSA 签名更简单。以下是使用公钥 $K_x$ 和消息 $m$ 验证签名 $(R_x, s)$ 的步骤：
首先，我们验证 $K_x$ 是一个有效的整数并且小于 $p$。如果是这样，我们就用 $K_y$ 是偶数的条件找到曲线上对应的点。我们还通过分离签名 $\text{SIG}$ 来提取 $R_x$ 和 $s$。然后，我们检查 $R_x < p$ 和 $s < n$（曲线的阶）。
接下来，我们以与签名发行者相同的方式计算挑战 $e$：

$$
e = \text{HASH}(\text{``BIP0340/challenge''}, R_x \Vert K_x \Vert m) \mod n
$$

然后，我们以这种方式计算曲线上的一个参考点：

$$
R' = s \cdot G - e \cdot K
$$

最后，我们验证 $R'_x = R_x$。如果两个 x 坐标匹配，那么签名 $(R_x, s)$ 确实是用公钥 $K_x$ 有效的。

### 为什么这有效？

签名者已经计算了 $s = r + e \cdot k \mod n$，所以 $R' = s \cdot G - e \cdot K$ 应该等于原始点 $R$，因为：

$$
s \cdot G = (r + e \cdot k) \cdot G = r \cdot G + e \cdot k \cdot G
$$

由于 $K = k \cdot G$，我们有 $e \cdot k \cdot G = e \cdot K$。因此：

$$
R' = r \cdot G = R
$$

因此，我们有：

$$
R'_x = R_x
$$

### Schnorr 签名的优势

Schnorr 签名方案为比特币提供了几个相对于原始的 ECDSA 算法的优势。首先，Schnorr 允许密钥和签名的聚合。这意味着多个公钥可以组合成一个单一的密钥。

![CYP201](assets/fr/024.webp)

同样，多个签名可以聚合成一个有效的签名。因此，在多签名交易的情况下，一组参与者可以使用单一签名和单一聚合公钥进行签名。这显著减少了网络的存储和计算成本，因为每个节点只需要验证单一签名。

![CYP201](assets/fr/025.webp)

此外，签名聚合改善了隐私。通过 Schnorr，将无法区分多签名交易和标准单签名交易。这种同质性使链分析更加困难，因为它限制了识别钱包指纹的能力。
最后，Schnorr签名还提供了批量验证的可能性。通过同时验证多个签名，节点可以提高效率，尤其是对于包含许多交易的区块。这种优化减少了验证区块所需的时间和资源。此外，与使用ECDSA产生的签名不同，Schnorr签名不可变形。这意味着攻击者不能修改一个有效签名来为同一消息和同一公钥创建另一个有效签名。这个漏洞之前存在于比特币上，并显著阻碍了闪电网络的安全实现。这个问题通过2017年的SegWit软分叉为ECDSA解决，该软分叉通过将签名移动到与交易分开的数据库中来防止其可变形。

### 为什么中本聪选择了ECDSA？

正如我们所见，中本聪最初选择在比特币上实现ECDSA进行数字签名。然而，我们也看到Schnorr在许多方面都优于ECDSA，而这个协议是由Claus-Peter Schnorr在1989年，比比特币发明前20年，创建的。

我们不确切知道为什么中本聪没有选择它，但一个可能的假设是这个协议直到2008年都处于专利之下。尽管比特币是在一年后的2009年1月创建的，但那时还没有Schnorr签名的开源标准化。也许中本聪认为使用ECDSA更安全，因为它已经在开源软件中被广泛使用和测试，并且有几个公认的实现（特别是直到2015年在比特币核心上使用的OpenSSL库，然后在0.10.0版本中被libsecp256k1替换）。或者他根本不知道这个专利将在2008年到期。无论如何，最可能的假设似乎与这个专利有关，以及ECDSA有一个被证明的历史并且更容易实现。

## 签名哈希标志

<chapterId>231c41a2-aff2-4655-9048-47b6d2d83d64</chapterId>

正如我们在前几章中所见，数字签名通常用于解锁输入的脚本。在签名过程中，需要在计算中包含已签名的数据，我们的示例中指定为消息$m$。一旦签名，这些数据就不能被修改，否则签名将无效。实际上，无论是对于ECDSA还是Schnorr，签名验证者都必须在他们的计算中包含相同的消息$m$。如果它与签名者最初使用的消息$m$不同，结果将是错误的，签名将被视为无效。然后，可以说一个签名覆盖了某些数据，并在某种程度上保护它免受未经授权的修改。

### 什么是签名哈希标志？

在比特币的特定情况下，我们已经看到消息$m$对应于交易。然而，实际上，情况更加复杂。事实上，多亏了签名哈希标志，可以选择交易内将被签名覆盖或不覆盖的特定数据。
因此，“签名哈希标志”是添加到每个输入的参数，允许确定交易的哪些组件被关联签名覆盖。这些组件是输入和输出。签名哈希标志的选择因此决定了交易的哪些输入和输出由签名固定，哪些可以在不使其失效的情况下进行修改。这种机制允许签名根据签名者的意图承诺交易数据。
显然，一旦交易在区块链上确认，无论使用了哪种sighash标志，它都变得不可变更。通过sighash标志修改的可能性仅限于签名和确认之间的时间段。

通常，钱包软件不提供手动修改您在构建交易时输入的sighash标志的选项。默认情况下，设置为`SIGHASH_ALL`。就我个人而言，我只知道Sparrow Wallet允许用户界面进行此类修改。

### Bitcoin上存在哪些sighash标志？

在Bitcoin上，首先有3个基本的sighash标志：

- `SIGHASH_ALL` (`0x01`): 签名适用于交易的所有输入和所有输出。因此，交易完全被签名覆盖，无法再被修改。`SIGHASH_ALL`是日常交易中最常用的sighash，当人们简单地想进行交易而不希望它被修改时会使用它。

![CYP201](assets/fr/026.webp)

在本章的所有图表中，橙色代表签名覆盖的元素，而黑色表示那些未被覆盖的。

- `SIGHASH_NONE` (`0x02`): 签名覆盖所有输入但不覆盖任何输出，从而允许在签名后修改输出。具体来说，这类似于一张空白支票。签名人解锁输入中的UTXOs，但留下完全可修改的输出字段。任何知道此交易的人因此可以添加他们选择的输出，例如通过指定一个接收地址来收集输入消耗的资金，然后广播交易以回收比特币。输入所有者的签名不会被作废，因为它只覆盖输入。

![CYP201](assets/fr/027.webp)

- `SIGHASH_SINGLE` (`0x03`): 签名覆盖所有输入以及单个输出，对应于已签名输入的索引。例如，如果签名解锁了输入#0的*scriptPubKey*，那么它也覆盖输出#0。签名还保护所有其他输入，这些输入无法再被修改。然而，任何人都可以添加额外的输出而不使签名失效，前提是不修改唯一被它覆盖的输出#0。
  ![CYP201](assets/fr/028.webp)

除了这三个sighash标志外，还有一个修饰符`SIGHASH_ANYONECANPAY` (`0x80`)。这个修饰符可以与基本sighash标志组合，创建三个新的sighash标志：

- `SIGHASH_ALL | SIGHASH_ANYONECANPAY` (`0x81`): 签名覆盖单个输入，同时包含交易的所有输出。这种组合的sighash标志允许例如创建一个众筹交易。组织者准备带有他们地址和目标金额的输出，每个投资者随后可以添加输入来资助这个输出。一旦输入中聚集了足够的资金来满足输出，交易就可以被广播。

![CYP201](assets/fr/029.webp)

- `SIGHASH_NONE | SIGHASH_ANYONECANPAY` (`0x82`): 签名覆盖单个输入，不承诺任何输出；

![CYP201](assets/fr/030.webp)

- `SIGHASH_SINGLE | SIGHASH_ANYONECANPAY`（`0x83`）：签名仅覆盖单个输入以及与此输入索引相同的输出。例如，如果签名解锁了输入#3的*scriptPubKey*，它也将覆盖输出#3。交易的其余部分仍可修改，包括其他输入和其他输出。
  ![CYP201](assets/fr/031.webp)

### 添加新的Sighash标志的项目

当前（2024年），比特币上只能使用前一节中介绍的sighash标志。然而，一些项目正在考虑添加新的sighash标志。例如，由Christian Decker和Anthony Towns提出的BIP118引入了两个新的sighash标志：`SIGHASH_ANYPREVOUT`和`SIGHASH_ANYPREVOUTANYSCRIPT`（_AnyPrevOut = “任何之前的输出”_）。

这两个sighash标志将在比特币上提供额外的可能性：创建不覆盖交易的任何特定输入的签名。

![CYP201](assets/fr/032.webp)

这个想法最初是由Joseph Poon和Thaddeus Dryja在闪电网络白皮书中提出的。在重命名之前，这个sighash标志被命名为`SIGHASH_NOINPUT`。
如果这个sighash标志被整合到比特币中，它将使得使用契约成为可能，但它也是实现Eltoo的必要前提，Eltoo是一个为第二层定义如何共同管理UTXO所有权的通用协议。Eltoo专门设计来解决与协商闪电通道状态（即，开启和关闭之间）相关的问题。

为了深入了解闪电网络，在CYP201课程之后，我强烈推荐由Fanis Michalakis开设的LNP201课程，该课程详细讲解了这个主题：

https://planb.network/courses/lnp201

在下一部分，我建议探索构成您比特币钱包基础的助记词是如何工作的。

# 助记词

<partId>4070af16-c8a2-58b5-9871-a22c86c07458</partId>

## 比特币钱包的演变

<chapterId>9d9acd5d-a0e5-5dfd-b544-f043fae8840f</chapterId>

现在我们已经探索了哈希函数和数字签名的工作原理，我们可以研究比特币钱包是如何工作的。目标将是想象一个比特币钱包是如何构建的，它是如何分解的，以及构成它的不同信息片段是用来做什么的。这种对钱包机制的理解将允许您在安全性和隐私性方面改善您使用比特币的方式。

在深入技术细节之前，有必要澄清“比特币钱包”是什么意思，并理解其用途。

### 什么是比特币钱包？

与允许您存储实体纸币和硬币的传统钱包不同，比特币钱包本身并不“包含”比特币。实际上，比特币并不存在于可以存储的物理或数字形式中，而是以**UTXOs**（_未花费交易输出_）的形式在系统中表示的账户单位。
UTXOs因此代表了不同大小的比特币碎片，只要满足其*scriptPubKey*，就可以花费这些碎片。用户要花费他的比特币，必须提供一个*scriptSig*来解锁与他的UTXO相关联的*scriptPubKey*。这种证明通常通过从与*scriptPubKey*中的公钥相对应的私钥生成的数字签名来完成。因此，用户必须保护的关键元素是私钥。比特币钱包的作用正是安全地管理这些私钥。实际上，它的角色更像是一个钥匙链而不是传统意义上的钱包。

### JBOK 钱包（_Just a Bunch Of Keys_）

比特币上最初使用的钱包是JBOK（_Just a Bunch Of Keys_）钱包，这些钱包将独立生成的私钥聚集在一起，彼此之间没有任何联系。这些钱包采用了一个简单的模型，其中每个私钥可以解锁一个独特的比特币接收地址。

![CYP201](assets/fr/033.webp)

如果希望使用多个私钥，则需要进行多次备份，以确保在托管钱包的设备出现问题时能够访问资金。如果使用单个私钥，这种钱包结构可能就足够了，因为单次备份就足够。然而，这就带来了一个问题：在比特币上，强烈建议不要总是使用同一个私钥。实际上，一个私钥与一个独特的地址相关联，而比特币接收地址通常设计为一次性使用。每次接收资金时，你都应该生成一个新的空白地址。

这个限制源自比特币的隐私模型。通过重用相同的地址，它使外部观察者更容易追踪我所有的比特币交易。这就是为什么强烈不鼓励重用接收地址的原因。然而，为了拥有多个地址并公开分隔我们的交易，就必须管理多个私钥。在JBOK钱包的情况下，这意味着需要创建与新的密钥对一样多的备份，这对用户来说可能很快变得复杂且难以维护。

要了解更多关于比特币隐私模型的信息，并发现保护你隐私的方法，我还推荐你关注我在Plan ₿ Network上的BTC204课程：

https://planb.network/courses/btc204

### HD 钱包（_层次化确定性_）

为了解决JBOK钱包的限制，后来采用了一种新的钱包结构。2012年，Pieter Wuille引入了BIP32的改进，它引入了层次化确定性钱包。HD钱包的原理是以确定性和层次化的方式从单一信息源（称为种子）派生所有私钥。这个种子在创建钱包时随机生成，并构成了一个独特的备份，允许重新创建所有钱包的私钥。因此，用户可以生成大量的私钥以避免地址重用并保护他们的隐私，同时只需要通过种子备份他们的钱包一次。
![CYP201](assets/fr/034.webp)

在HD钱包中，密钥派生按照层次结构进行，允许将密钥组织到派生子空间中，每个子空间进一步可细分，以便于资金管理和不同钱包软件之间的互操作性。如今，这一标准被绝大多数比特币用户采用。因此，我们将在接下来的章节中详细检查它。

### BIP39标准：助记词短语

除了BIP32之外，BIP39还将种子格式标准化为助记词组，以便用户备份和阅读。助记词组，也称为恢复短语或24字短语，是从预定义列表中选取的单词序列，用于安全编码钱包的种子。

助记词组极大地简化了用户的备份过程。在设备丢失、损坏或被盗的情况下，只需知道这个助记词组，就可以重新创建钱包并恢复对所有资金的访问权限。

在接下来的章节中，我们将探索HD钱包的内部工作原理，包括密钥派生机制和可能的不同层次结构。这将帮助您更好地理解比特币资金安全所依赖的加密基础。首先，在下一章中，我建议我们发现钱包基础上的熵的作用。

## 熵和随机数

<chapterId>b43c715d-affb-56d8-a697-ad5bc2fffd63</chapterId>
现代HD钱包（确定性和层次性）依赖于一个称为“熵”的单一初始信息来确定性地生成整个钱包密钥集。这个熵是一个伪随机数，其混乱程度部分决定了钱包的安全性。

### 熵的定义

在密码学和信息学的背景下，熵是与数据源或随机过程相关联的不确定性或不可预测性的量化度量。它在加密系统的安全性中扮演着重要角色，特别是在生成密钥和随机数时。高熵确保生成的密钥足够不可预测，并且能抵抗暴力攻击，即攻击者尝试所有可能的组合来猜测密钥。

在比特币的背景下，熵被用来生成种子。创建确定性和层次性钱包时，助记词组的构建是从一个随机数开始的，这个随机数本身来自于一个熵源。然后使用该短语以确定性和层次性的方式生成多个私钥，以在UTXOs上创建消费条件。

### 生成熵的方法

HD钱包的初始熵通常是128位或256位，其中：

- **128位的熵**对应于**12个单词**的助记词组；
- **256位的熵**对应于**24个单词**的助记词组。

在大多数情况下，这个随机数是由钱包软件使用PRNG（_伪随机数生成器_）自动生成的。PRNG是一类算法，用于从初始状态生成数列，这些数列具有接近随机数的特性，但实际上并不是随机数。一个好的PRNG必须具有输出均匀性、不可预测性和抵抗预测攻击的特性。与真随机数生成器（TRNG）不同，PRNG是确定性的和可重现的。

![CYP201](assets/fr/035.webp)

另一种方法是手动生成熵，这提供了更好的控制，但也风险更大。我强烈建议不要自己为您的HD钱包生成熵。

在下一章中，我们将看到如何从一个随机数转换到一个12或24个单词的助记词组。

## 助记词组

<chapterId>8f9340c1-e6dc-5557-a2f2-26c9669987d5</chapterId>
助记词组，也称为“种子短语”、“恢复短语”、“秘密短语”或“24字短语”，通常由12个或24个单词组成的序列，这个序列是从熵生成的。它用于确定性地派生出HD钱包的所有密钥。这意味着从这个短语出发，可以确定性地生成和重建比特币钱包的所有私钥和公钥，因此可以访问用它保护的资金。助记词组的目的是提供一种既安全又易于使用的比特币备份和恢复手段。它在2013年通过BIP39标准引入。
让我们一起探索如何从熵生成助记词组。

### 校验和

要将熵转换为助记词组，首先必须在熵的末尾添加一个校验和（或“控制和”）。这个校验和是一个短的位序列，通过验证数据没有发生意外修改来确保数据的完整性。

计算校验和时，对熵应用SHA256哈希函数（只应用一次；这是比特币中少数使用单个SHA256哈希而不是双重哈希的情况之一）。这个操作产生一个256位的哈希。校验和由这个哈希的前几位组成，其长度取决于熵的长度，按照以下公式：

$$
\text{CS} = \frac{\text{ENT}}{32}
$$

其中 $\text{ENT}$ 代表熵的长度（以位为单位），$\text{CS}$ 代表校验和的长度（以位为单位）。

例如，对于256位的熵，取哈希的前8位来形成校验和：

$$
\text{CS} = \frac{256}{32} = 8 \text{ bits}
$$

计算出校验和后，将其与熵连接起来，得到一个扩展的位序列，记为 $\text{ENT} \Vert \text{CS}$（“连接”意味着端到端地放置）。

![CYP201](assets/fr/036.webp)

### 熵与助记词组之间的对应关系

助记词组中的单词数量取决于初始熵的大小，如下表所示，包括：

- $\text{ENT}$：熵的大小（以位为单位）；
- $\text{CS}$：校验和的大小（以位为单位）；
- $w$：最终助记词组中的单词数量。

$$
\begin{array}{|c|c|c|c|}
\hline
\text{ENT} & \text{CS} & \text{ENT} \Vert \text{CS} & w \\
\hline
128 & 4 & 132 & 12 \\
160 & 5 & 165 & 15 \\
192 & 6 & 198 & 18 \\
224 & 7 & 231 & 21 \\
256 & 8 & 264 & 24 \\
\hline
\end{array}
$$

例如，对于256位的熵，结果 $\text{ENT} \Vert \text{CS}$ 是264位，并产生24个单词的助记词组。

### 将二进制序列转换为助记词组

位序列 $\text{ENT} \Vert \text{CS}$ 然后被分割成11位的段。每个11位的段，一旦转换为十进制，对应于一个介于0到2047之间的数字，这个数字指定了[由BIP39标准化的2048个单词列表中](https://github.com/Planb-Network/bitcoin-educational-content/blob/dev/resources/bet/bip39-wordlist/assets/BIP39-WORDLIST.pdf)的一个单词的位置。

![CYP201](assets/fr/037.webp)
例如，对于128位的熵，校验和是4位，因此总序列长度为132位。它被分成12个11位的段（橙色位指的是校验和）：
![CYP201](assets/fr/038.webp)

然后，每个段都被转换成一个十进制数，这个数代表列表中的一个词。例如，二进制段`01011010001`在十进制中等于`721`。为了与列表的索引对齐（从1开始而不是0），这给出了单词排名`722`，在列表中是“*focus*”。

![CYP201](assets/fr/039.webp)

这种对应关系对每个12个段重复一次，以获得一个12词的短语。

![CYP201](assets/fr/040.webp)

### BIP39词表的特点

BIP39词表的一个特点是，没有任何一个词的前四个字母按相同顺序与另一个词相同。这意味着，只记录每个词的前四个字母就足以保存助记词短语。这对于节省空间来说很有趣，特别是对于那些希望将其刻在金属支持上的人来说。

这个包含2048个词的列表存在于几种语言中。这些不是简单的翻译，而是每种语言的不同词汇。然而，强烈建议坚持使用英文版本，因为其他语言的版本通常不被钱包软件支持。

### 如何选择您的助记词短语的长度？
要确定助记词短语的最佳长度，必须考虑它提供的实际安全性。一个12词的短语确保了128位的安全性，而一个24词的短语提供了256位。

然而，这种短语级别的安全性差异并没有提高比特币钱包的整体安全性，因为从这个短语派生出的私钥只受益于128位的安全性。事实上，正如我们之前看到的，比特币私钥是从随机数（或从随机源）生成的，范围在$1$和$n-1$之间，其中$n$代表secp256k1曲线的生成点$G$的阶，这个数略小于$2^{256}$。因此，人们可能会认为这些私钥提供了256位的安全性。然而，它们的安全性在于从其关联的公钥找到私钥的难度，这个难度是由椭圆曲线上的离散对数问题（*ECDLP*）的数学问题确定的。到目前为止，解决这个问题的最佳已知算法是Pollard的rho算法，它将破解密钥所需的操作数量减少到其大小的平方根。

对于比特币上使用的256位密钥，Pollard的rho算法因此将复杂性降低到$2^{128}$操作：


$$

O(\sqrt{2^{256}}) = O(2^{128})

$$

因此，认为在比特币上使用的私钥提供了128位的安全性。

结果，选择一个24词的短语并没有为钱包提供额外的保护，因为如果派生出的密钥只提供128位的安全性，那么短语上的256位安全性就毫无意义。举个例子，这就像有一个房子有两扇门：一扇旧木门和一扇加固门。在发生入室盗窃的情况下，加固门将无济于事，因为入侵者会通过木门。这里就是一个类似的情况。
一个由12个词组成的短语，因此提供了128位的安全性，目前足以保护您的比特币免受任何盗窃尝试。只要数字签名算法不改用更大的密钥或依赖于除ECDLP之外的数学问题，一个24个词的短语就显得多余。此外，较长的短语在备份时增加了丢失的风险：长度是原来一半的备份总是更容易管理。

要进一步了解如何手动生成测试助记词短语，请参阅此教程：

https://planb.network/tutorials/wallet/backup/generate-mnemonic-phrase-47507d90-e6af-4cac-b01b-01a14d7a8228

在继续从这个助记词短语派生钱包之前，我将在下一章向您介绍BIP39密码短语，因为它在派生过程中起着作用，与助记词短语处于同一水平。

## 密码短语
<chapterId>6a51b397-f3b5-5084-b151-cef94bc9b93f</chapterId>

正如我们刚刚看到的，HD钱包是从通常由12个或24个词组成的助记词短语生成的。这个短语非常重要，因为它允许在钱包的物理设备（例如，硬件钱包）丢失的情况下恢复所有钥匙。然而，它构成了一个单点故障，因为如果它被泄露，攻击者可以窃取所有比特币。这就是BIP39密码短语发挥作用的地方。

### 什么是BIP39密码短语？

密码短语是一个可选的密码，您可以自由选择，它在密钥派生过程中添加到助记词短语中，以增强钱包的安全性。

注意，密码短语不应与您的硬件钱包的PIN码或用于解锁您的电脑上钱包访问的密码混淆。与所有这些元素不同，密码短语在您钱包的密钥派生中起作用。**这意味着没有它，您将永远无法恢复您的比特币。**

密码短语与助记词短语配合使用，修改生成密钥的种子。因此，即使有人获得了您的12个或24个词的短语，没有密码短语，他们也无法访问您的资金。使用密码短语本质上创建了一个具有不同密钥的新钱包。修改（即使是轻微的）密码短语将生成一个不同的钱包。

![CYP201](assets/fr/041.webp)

### 为什么您应该使用密码短语？

密码短语是任意的，可以是用户选择的任何字符组合。因此，使用密码短语提供了几个优点。首先，它通过要求第二因素来访问资金（入室盗窃，进入您的家等），降低了与助记词短语泄露相关的所有风险。

接下来，它可以被战略性地用来创建一个诱饵钱包，以面对像臭名昭著的“_$5扳手攻击_”这样的物理约束来窃取您的资金。在这种情况下，想法是拥有一个不带密码短语的钱包，只包含少量比特币，足以满足潜在的攻击者，同时拥有一个隐藏的钱包。这后者使用相同的助记词短语，但是用一个额外的密码短语进行了保护。
最后，当希望控制HD钱包的种子生成的随机性时，使用密码短语是有趣的。
### 如何选择一个好的密码短语？

为了密码短语有效，它必须足够长且随机。就像一个强密码一样，我建议选择一个尽可能长和随机的密码短语，包含字母、数字和符号的多样性，以使任何暴力攻击变得不可能。
同样重要的是要正确保存这个密码短语，就像保存助记词一样。**丢失它意味着失去访问比特币的权限**。我强烈建议不要仅凭记忆来记住它，因为这无理增加了丢失的风险。理想的做法是将其写在物理介质（纸或金属）上，并与助记词分开。这份备份显然必须存放在与助记词不同的地方，以防两者同时被泄露。

![CYP201](assets/fr/042.webp)

在接下来的部分，我们将发现这两个构成你的钱包基础的元素 — 助记词和密码短语 — 是如何用来派生用于锁定你的UTXOs的*scriptPubKey*中的密钥对的。

# 比特币钱包的创建

<partId>9c25e767-7eae-50b8-8c5f-679d8fc83bab</partId>

## 种子和主密钥的创建

<chapterId>63093760-2010-5691-8d0e-9a04732ae557</chapterId>

一旦生成了助记词和可选的密码短语，就可以开始派生比特币HD钱包的过程了。首先将助记词转换成种子，这构成了钱包所有密钥的基础。

![CYP201](assets/fr/043.webp)

### HD钱包的种子

BIP39标准定义了种子为一个512位序列，它作为派生HD钱包所有密钥的起点。种子是从助记词和可能的密码短语中派生出来的，使用的是**PBKDF2**算法（*基于密码的密钥派生函数2*），我们已经在第3.3章讨论过了。在这个派生函数中，我们将使用以下参数：

- $m$ : 助记词；
- $p$ : 用户选择的可选密码短语，用于增强种子的安全性。如果没有密码短语，这个字段留空；
- $\text{PBKDF2}$ : 派生函数，使用$\text{HMAC-SHA512}$和$2048$次迭代；
- $s$: 512位的钱包种子。
无论选择的助记词长度是132位还是264位，PBKDF2函数总是会产生一个512位的输出，因此种子的大小总是这个大小。

### 使用PBKDF2的种子派生方案

下面的等式展示了从助记词和密码短语派生种子的过程：


$$

s = \text{PBKDF2}_{\text{HMAC-SHA512}}(m, p, 2048)

$$

![CYP201](assets/fr/044.webp)

因此，种子的值受到助记词和密码短语的值的影响。通过改变密码短语，可以获得不同的种子。然而，使用相同的助记词和密码短语，总是生成相同的种子，因为PBKDF2是一个确定性函数。这确保了可以通过我们的备份检索到相同的密钥对。

**注意：**在通常的语言中，术语“种子”经常被误用来指助记词。实际上，在没有密码短语的情况下，一个简单地编码了另一个。然而，正如我们所见，在钱包的技术实际中，种子和助记词确实是两个不同的元素。

现在我们有了我们的种子，我们可以继续进行我们的比特币钱包的派生了。
### 主密钥和主链码
一旦获得种子，派生HD钱包的下一步就是计算主私钥和主链码，这将代表我们钱包的0级深度。

为了获得主私钥和主链码，将使用固定密钥“*Bitcoin Seed*”对种子应用HMAC-SHA512函数，该密钥对所有比特币用户都是相同的。选择这个常数是为了确保密钥派生特定于比特币。这里是元素：
- $\text{HMAC-SHA512}$：派生函数；
- $s$：512位钱包种子；
- $\text{"Bitcoin Seed"}$：所有比特币钱包的共同派生常数。


$$

\text{output} = \text{HMAC-SHA512}(\text{"Bitcoin Seed"}, s)

$$

因此，此函数的输出为512位。然后它被分为两部分：
- 左边的256位形成**主私钥**；
- 右边的256位形成**主链码**。
数学上，这两个值可以如下表示，$k_M$是主私钥，$C_M$是主链码：
$$

k_M = \text{HMAC-SHA512}(\text{"Bitcoin Seed"}, s)_{[:256]}

$$


$$

C_M = \text{HMAC-SHA512}(\text{"Bitcoin Seed"}, s)_{[256:]}

$$

![CYP201](assets/fr/045.webp)

### 主密钥和链码的作用

主私钥被视为父密钥，所有派生的私钥——子密钥、孙子密钥、曾孙子密钥等——都将从中生成。它代表了派生层次结构中的零级。

另一方面，主链码引入了额外的熵源到子密钥的派生过程中，以对抗某些潜在的攻击。此外，在HD钱包中，每对密钥都有一个与之关联的唯一链码，也用于从这对密钥派生子密钥，但我们将在后续章节中更详细地讨论这一点。

在继续进行HD钱包的派生之前，我希望在下一章向您介绍扩展密钥，这些密钥经常与主密钥混淆。我们将看到它们是如何构建的以及它们在比特币钱包中扮演什么角色。

## 扩展密钥
<chapterId>8dcffce1-31bd-5e0b-965b-735f5f9e4602</chapterId>

扩展密钥简单来说就是密钥（无论是私钥还是公钥）及其关联链码的连接。这个链码对于派生子密钥至关重要，因为没有它，就无法从父密钥派生子密钥，但我们将在下一章中更准确地发现这一过程。因此，这些扩展密钥允许聚合派生子密钥所需的所有必要信息，从而简化了HD钱包内的账户管理。

![CYP201](assets/fr/046.webp)

扩展密钥由两部分组成：
- 有效载荷，包含私钥或公钥以及关联的链码；
- 元数据，是各种信息，以促进软件之间的互操作性并提高用户的理解。
当扩展密钥包含一个私钥时，它被称为扩展私钥。它通过其前缀被识别，该前缀包含`prv`的提及。除了私钥外，扩展私钥还包含关联的链码。有了这种类型的扩展密钥，就可以派生所有类型的子私钥，因此通过在椭圆曲线上加法和倍乘，也允许派生全部的子公钥。

当扩展密钥不包含私钥，而是包含一个公钥时，它被称为扩展公钥。它通过其前缀被识别，该前缀包含`pub`的提及。显然，除了密钥外，它还包含关联的链码。与扩展私钥不同，扩展公钥只允许派生“普通”的子公钥（意味着它不能派生“加固”的子密钥）。在接下来的章节中，我们将看到这些“普通”和“加固”限定词的含义。

但无论如何，扩展公钥不允许派生子私钥。因此，即使有人拥有`xpub`，他们也无法花费关联的资金，因为他们无法访问相应的私钥。他们只能派生子公钥来观察关联的交易。

对于接下来的内容，我们将采用以下符号：
- $K_{\text{PAR}}$：一个父公钥；
- $k_{\text{PAR}}$：一个父私钥；
- $C_{\text{PAR}}$：一个父链码；
- $C_{\text{CHD}}$：一个子链码；
- $K_{\text{CHD}}^n$：一个普通子公钥；
- $k_{\text{CHD}}^n$：一个普通子私钥；
- $K_{\text{CHD}}^h$：一个加固子公钥；
- $k_{\text{CHD}}^h$：一个加固子私钥。

![CYP201](assets/fr/047.webp)

### 扩展密钥的构造

扩展密钥的结构如下：
- **版本**：版本代码用于识别密钥的性质（`xprv`、`xpub`、`yprv`、`ypub`...）。我们将在本章末尾看到字母`x`、`y`和`z`对应的含义。
- **深度**：在HD钱包中相对于主密钥的层次级别（主密钥为0）。
- **父指纹**：用于派生当前密钥的父公钥的HASH160哈希的前4个字节。
- **索引号**：在同一派生级别拥有相同父密钥的所有密钥中，子密钥的标识符。
- **链码**：用于派生子密钥的唯一32字节代码。
- **密钥**：私钥（由1字节的大小前缀）或公钥。
- **校验和**：还添加了一个用HASH256函数（双重SHA256）计算的校验和，它允许在传输或存储扩展密钥时验证其完整性。

因此，扩展密钥的完整格式是78字节（不含校验和），带校验和是82字节。然后将其转换为Base58格式，以产生用户易于阅读的表示形式。Base58格式与用于*Legacy*接收地址（在*SegWit*之前）的格式相同。

| 元素             | 描述                                                                                                              | 大小      |
| ----------------- | ------------------------------------------------------------------------------------------------------------------ | --------- |
| 版本              | 表示密钥是公开的（`xpub`、`ypub`）还是私有的（`xprv`、`zprv`），以及扩展密钥的版本                                      | 4 字节    |
| 深度              | 相对于主密钥在层次结构中的级别                                                                                      | 1 字节    |
| 父指纹            | 父公钥的 HASH160 的前 4 字节                                                                                        | 4 字节    |
| 索引号            | 密钥在子密钥序列中的位置                                                                                            | 4 字节    |
| 链码              | 用于派生子密钥                                                                                                      | 32 字节   |
| 密钥              | 私钥（带有 1 字节前缀）或公钥                                                                                       | 33 字节   |
| 校验和            | 用于验证完整性的校验和                                                                                              | 4 字节    |

如果私钥只增加了一个字节，那是因为压缩公钥比私钥长一个字节。这个额外的字节，作为 `0x00` 添加在私钥的开始处，使它们的大小相等，确保无论是公钥还是私钥，扩展密钥的有效载荷长度都是相同的。

### 扩展密钥前缀
正如我们刚才看到的，扩展密钥包括一个前缀，该前缀指示扩展密钥的版本及其性质。符号 `pub` 表示它指的是一个扩展公钥，而符号 `prv` 表示一个扩展私钥。扩展密钥基础上的额外字母有助于指示遵循的标准是传统的、SegWit v0、SegWit v1 等。
这里是使用的前缀及其含义的总结：

| Base 58 Prefix  | Base 16 Prefix  | Network | Purpose             | Associated Scripts  | Derivation            | Key Type     |
| --------------- | --------------- | ------- | ------------------- | ------------------- | --------------------- | ------------ |
| `xpub`          | `0488b21e`      | Mainnet | Legacy and SegWit V1 | P2PK / P2PKH / P2TR | `m/44'/0'`, `m/86'/0'` | public       |
| `xprv`          | `0488ade4`      | Mainnet | Legacy and SegWit V1 | P2PK / P2PKH / P2TR | `m/44'/0'`, `m/86'/0'` | private      |
| `tpub`          | `043587cf`      | Testnet | Legacy and SegWit V1 | P2PK / P2PKH / P2TR | `m/44'/1'`, `m/86'/1'` | public       |
| `tprv`          | `04358394`      | Testnet | Legacy and SegWit V1 | P2PK / P2PKH / P2TR | `m/44'/1'`, `m/86'/1'` | private      |
| `ypub`          | `049d7cb2`      | Mainnet | Nested SegWit       | P2WPKH in P2SH      | `m/49'/0'`             | public       |
| `yprv`          | `049d7878`      | Mainnet | Nested SegWit       | P2WPKH in P2SH      | `m/49'/0'`             | private      |
| `upub`          | `049d7cb2`      | Testnet | Nested SegWit       | P2WPKH in P2SH      | `m/49'/1'`             | public       |
| `uprv`          | `044a4e28`      | Testnet | Nested SegWit       | P2WPKH in P2SH      | `m/49'/1'`             | private      |
| `zpub`          | `04b24746`      | Mainnet | SegWit V0           | P2WPKH              | `m/84'/0'`             | public       |
| `zprv`          | `04b2430c`      | Mainnet | SegWit V0           | P2WPKH              | `m/84'/0'`             | private      |
| `vpub`          | `045f1cf6`      | Testnet | SegWit V0           | P2WPKH              | `m/84'/1'`             | public       |
| `vprv`          | `045f18bc`      | Testnet | SegWit V0           | P2WPKH              | `m/84'/1'`             | private      |

### 扩展密钥元素的详细信息

为了更好地理解扩展密钥的内部结构，让我们以一个扩展密钥为例并分解它。这里有一个扩展密钥：

- **Base58中**:

```text
xpub6CTNzMUkzpurBWaT4HQoYzLP4uBbGJuWY358Rj7rauiw4rMHCyq3Rfy9w4kyJXJzeFfyrKLUar2rUCukSiDQFa7roTwzjiAhyQAdPLEjqHT
```

- **十六进制中**:

```text
0488B21E036D5601AD80000000C605DF9FBD77FD6965BD02B77831EC5C78646AD3ACA14DC3984186F72633A89303772CCB99F4EF346078D167065404EED8A58787DED31BFA479244824DF50658051F067C3A
```

这个扩展密钥分解成几个不同的元素：

1. **版本**: `0488B21E`

前4个字节是版本。这里，它对应于主网上的一个扩展公钥，派生用途为*传统*或*SegWit v1*。

2. **深度**: `03`

此字段指示密钥在HD钱包内的层次级别。在这个例子中，深度为`03`意味着这个密钥是从主密钥下三级派生的。

3. **父指纹**: `6D5601AD`
   这是父公钥HASH160哈希的前4个字节，用于派生此`xpub`。
4. **索引号**：`80000000`

此索引指示密钥在其父级子项中的位置。`0x80`前缀表明密钥是以加固方式派生的，由于其余部分填充了零，这表明这个密钥是其可能的兄弟姐妹中的第一个。

5. **链码**：`C605DF9FBD77FD6965BD02B77831EC5C78646AD3ACA14DC3984186F72633A893`
6. **公钥**：`03772CCB99F4EF346078D167065404EED8A58787DED31BFA479244824DF5065805`
7. **校验和**：`1F067C3A`

校验和对应于其他所有内容的哈希（双重SHA256）的前4个字节。

在本章中，我们发现有两种不同类型的子密钥。我们还了解到，这些子密钥的派生需要一个密钥（无论是私钥还是公钥）及其链码。在下一章中，我们将详细探讨这些不同类型的密钥的性质以及如何从其父密钥和链码中派生它们。

## 子密钥对的派生

<chapterId>61c0807c-845b-5076-ad06-7f395b36adfd</chapterId>

在比特币HD钱包中，子密钥对的派生依赖于一个层次结构，该结构允许生成大量的密钥，同时通过分支将这些对组织成不同的组。从父对派生的每个子对都可以直接用在*scriptPubKey*中来锁定比特币，或作为生成更多子密钥的起点，依此类推，创建一个密钥树。

所有这些派生都从深度级别0的主密钥和主链码开始，它们在某种意义上是你钱包密钥的亚当和夏娃，所有派生密钥的共同祖先。

![CYP201](assets/fr/048.webp)

让我们探索这种确定性派生是如何工作的。

### 子密钥派生的不同类型

正如我们在前一章简要提到的：子密钥分为两大类型：

1. **普通子密钥** ($k_{\text{CHD}}^n, K_{\text{CHD}}^n$)：这些是从扩展公钥($K_{\text{PAR}}$)或扩展私钥($k_{\text{PAR}}$)派生的，首先通过派生公钥。
2. **加固子密钥** ($k_{\text{CHD}}^h, K_{\text{CHD}}^h$)：这些只能从扩展私钥($k_{\text{PAR}}$)派生，因此对于只拥有扩展公钥的观察者来说是不可见的。
   每个子密钥对都通过一个32位的**索引**（在我们的计算中命名为$i$）来识别。普通密钥的索引范围从$0$到$2^{31}-1$，而加固密钥的索引范围从$2^{31}$到$2^{32}-1$。这些数字用于在派生过程中区分兄弟密钥对。实际上，每个父密钥对都必须能够派生多个子密钥对。如果我们对父密钥应用相同的计算，得到的所有兄弟密钥将会是相同的，这是不可取的。因此，索引引入了一个变量，修改了派生计算，允许区分每对兄弟密钥。除了在某些协议和派生标准中的特定使用外，我们通常从索引`0`开始派生第一个子密钥，然后是索引`1`的第二个子密钥，依此类推。

### 使用HMAC-SHA512的派生过程

每个子密钥的派生基于HMAC-SHA512函数，我们在第2节关于哈希函数的讨论中提到过。它需要两个输入：父链码$C_{\text{PAR}}$和父密钥（公钥$K_{\text{PAR}}$或私钥$k_{\text{PAR}}$，取决于所需子密钥的类型）与索引的连接。HMAC-SHA512的输出是一个512位序列，分为两部分：

- **前32字节**（或$h_1$）用于计算新的子对。
- **后32字节**（或$h_2$）作为子对的新链码$C_{\text{CHD}}$。

在我们所有的计算中，我将用$\text{hash}$表示HMAC-SHA512函数的输出。

![CYP201](assets/fr/049.webp)

#### 从父私钥派生子私钥

要从父私钥$k_{\text{PAR}}$派生子私钥$k_{\text{CHD}}$，根据是需要加固密钥还是普通密钥，有两种可能的情况。

对于**普通子密钥**（$i < 2^{31}$），$\text{hash}$的计算如下：


$$

\text{hash} = \text{HMAC-SHA512}(C_{\text{PAR}}, G \cdot k_{\text{PAR}} \Vert i)

$$

在这个计算中，我们观察到我们的HMAC函数需要两个输入：首先是父链码，然后是索引与父私钥相关联的公钥的连接。这里使用父公钥是因为我们要派生一个普通子密钥，而不是加固密钥。
我们现在有了一个64字节的$\text{hash}$，我们将其分成两部分，每部分32字节：$h_1$和$h_2$：


$$

\text{hash} = h_1 \Vert h_2

$$


$$

h*1 = \text{hash}_{[:32]} \quad, \quad h*2 = \text{hash}_{[32:]}

$$

然后按如下方式计算子私钥$k_{\text{CHD}}^n$：


$$

k_{\text{CHD}}^n = \text{parse256}(h_1) + k_{\text{PAR}} \mod n

$$

在这个计算中，操作 $\text{parse256}(h_1)$ 包括将 $\text{hash}$ 的前32字节解释为一个256位整数。然后，这个数字加上父私钥，所有操作都取模 $n$ 以保持在椭圆曲线的阶内，正如我们在第3节关于数字签名所看到的。因此，为了派生一个普通的子私钥，尽管父公钥被用作HMAC-SHA512函数输入的计算基础，但始终需要有父私钥来完成计算。
从这个子私钥，可以通过应用ECDSA或Schnorr来派生相应的公钥。这样，我们获得了一对完整的密钥。

然后，$\text{hash}$ 的第二部分简单地被解释为我们刚刚派生的子密钥对的链码：


$$

C\_{\text{CHD}} = h_2

$$

这是整体派生的示意表示：

![CYP201](assets/fr/050.webp)

对于**加固的子密钥**（$i \geq 2^{31}$），$\text{hash}$ 的计算如下：


$$

hash = \text{HMAC-SHA512}(C_{\text{PAR}}, 0x00 \Vert k_{\text{PAR}} \Vert i)

$$

在这个计算中，我们观察到我们的HMAC函数接受两个输入：首先是父链码，然后是索引与父私钥的连接。这里使用父私钥是因为我们正在寻求派生一个加固的子密钥。此外，在密钥的开始处添加了一个等于 `0x00` 的字节。这个操作使其长度等同于压缩公钥的长度。
所以，我们现在有了一个64字节的 $\text{hash}$，我们将其分成两部分，每部分32字节：$h_1$ 和 $h_2$：


$$

\text{hash} = h_1 \Vert h_2

$$


$$

h_1 = \text{hash}[:32] \quad, \quad h_2 = \text{hash}[32:]

$$

然后按如下方式计算子私钥 $k_{\text{CHD}}^h$：


$$

k_{\text{CHD}}^h = \text{parse256}(h_1) + k_{\text{PAR}} \mod n

$$

接下来，我们简单地将 $\text{hash}$ 的第二部分解释为我们刚刚派生的子密钥对的链码：


$$

C\_{\text{CHD}} = h_2

$$

这是整体派生的示意表示：

![CYP201](assets/fr/051.webp)

我们可以看到，普通派生和加固派生的功能方式相同，不同之处在于：普通派生使用父公钥作为HMAC函数的输入，而加固派生使用父私钥。

#### 从父公钥派生子公钥

如果我们只知道父公钥 $K_{\text{PAR}}$ 和相关的链码 $C_{\text{PAR}}$，即一个扩展公钥，那么就有可能派生出子公钥 $K_{\text{CHD}}^n$，但仅限于普通（非强化）子密钥。这一原则显著地允许从 `xpub`（_仅观察_）监控比特币钱包中一个账户的活动。
为了执行这个计算，我们将使用一个索引 $i < 2^{31}$（普通派生）来计算 $\text{hash}$：


$$

\text{hash} = \text{HMAC-SHA512}(C_{\text{PAR}}, K_{\text{PAR}} \Vert i)

$$

在这个计算中，我们观察到我们的HMAC函数接受两个输入：首先是父链码，然后是索引与父公钥的连接。

所以，我们现在有了一个64字节的 $hash$，我们将其分成两部分，每部分32字节：$h_1$ 和 $h_2$：


$$

\text{hash} = h_1 \Vert h_2

$$


$$

h_1 = \text{hash}[:32] \quad, \quad h_2 = \text{hash}[32:]

$$

然后按照以下方式计算子公钥 $K_{\text{CHD}}^n$：


$$

K_{\text{CHD}}^n = G \cdot \text{parse256}(h_1) + K_{\text{PAR}}

$$

如果 $\text{parse256}(h_1) \geq n$（椭圆曲线的阶）或者如果 $K_{\text{CHD}}^n$ 是无穷远点，那么派生是无效的，必须选择另一个索引。
在这个计算中，操作 $\text{parse256}(h_1)$ 涉及将 $\text{hash}$ 的前32字节解释为一个256位整数。这个数字用于通过加法和加倍从生成点 $G$ 计算椭圆曲线上的一个点。然后将这个点加到父公钥上以获得普通子公钥。因此，要派生一个普通子公钥，只需要父公钥和父链码；与我们之前看到的子私钥的计算不同，父私钥从未参与这个过程。

接下来，子链码简单地是：


$$

C\_{\text{CHD}} = h_2

$$

这是整体派生的示意表示：

![CYP201](assets/fr/052.webp)

### 子公钥与子私钥之间的对应关系

可能会出现的一个问题是，如何从父公钥派生的普通子公钥与从相应的父私钥派生的普通子私钥相对应。这种链接正是通过椭圆曲线的属性确保的。实际上，为了派生一个普通子公钥，以相同的方式应用HMAC-SHA512，但其输出使用方式不同：

- **普通子私钥**：$k_{\text{CHD}}^n = \text{parse256}(h_1) + k_{\text{PAR}} \mod n$
- **普通子公钥**：$K_{\text{CHD}}^n = G \cdot \text{parse256}(h_1) + K_{\text{PAR}}$
  感谢椭圆曲线上的加法和加倍操作，这两种方法都产生了一致的结果：从子私钥派生的公钥与直接从父公钥派生的子公钥相同。

### 派生类型总结

总结一下，以下是不同可能的派生类型：

$$
\begin{array}{|c|c|c|c|}
\hline
\rightarrow & \text{PAR} & \text{CHD} & \text{n/h} \\
\hline
k_{\text{PAR}} \rightarrow k_{\text{CHD}} & k_{\text{PAR}} & \{ k_{\text{CHD}}^n, k_{\text{CHD}}^h \} & \{ n, h \} \\
k_{\text{PAR}} \rightarrow K_{\text{CHD}} & k_{\text{PAR}} & \{ K_{\text{CHD}}^n, K_{\text{CHD}}^h \} & \{ n, h \} \\
K_{\text{PAR}} \rightarrow k_{\text{CHD}} & K_{\text{PAR}} & \times & \times \\
K_{\text{PAR}} \rightarrow K_{\text{CHD}} & K_{\text{PAR}} & K_{\text{CHD}}^n & n \\
\hline
\end{array}
$$

总结一下，到目前为止，您已经学会了创建HD钱包的基本元素：助记词、种子，然后是主密钥和主链代码。在本章中，您还发现了如何派生子密钥对。在下一章中，我们将探讨这些派生在比特币钱包中是如何组织的，以及遵循什么结构来具体获得接收地址以及在*scriptPubKey*和*scriptSig*中使用的密钥对。

## 钱包结构和派生路径

<chapterId>34e1bbda-67de-5493-b268-1fded8d67689</chapterId>

比特币上HD钱包的层次结构允许以各种方式组织密钥对。其思想是从主私钥和主链代码派生出几个深度级别。每增加一个级别对应于从父密钥对派生出一个子密钥对。

随着时间的推移，不同的BIPs（_比特币改进提案_）引入了这些派生路径的标准，旨在标准化它们在不同软件中的使用。因此，在本章中，我们将根据这些标准，发现HD钱包中每个派生级别的含义。

### HD钱包的派生深度

派生路径被组织成深度层次，从深度0开始，代表主密钥和主链代码，到用于派生用于锁定UTXOs的地址的子级别。BIPs定义了每一层的标准，这有助于在不同的钱包管理软件中协调实践。

因此，派生路径指的是用于从主密钥派生子密钥的索引序列。

**深度0：主密钥（BIP32）**

这个深度对应于钱包的主私钥和主链代码。它由符号$m/$表示。

**深度1：目的（BIP43）**
目标决定了推导的逻辑结构。例如，一个P2WPKH地址在深度1将有$/84'/$（根据BIP84），而一个P2TR地址将有$/86'/$（根据BIP86）。这一层通过指示与BIP编号对应的索引号，促进了钱包之间的兼容性。
换句话说，一旦你拥有了主密钥和主链代码，这些就作为父密钥对来派生子密钥对。在这种派生中使用的索引可以是$/84'/$，例如，如果钱包旨在使用SegWit v0类型的脚本。然后这个密钥对位于深度1。它的角色不是锁定比特币，而仅仅是作为派生层次结构中的一个路标。

**深度2：货币类型（BIP44）**

从深度1的密钥对开始，执行新的派生以获得深度2的密钥对。这个深度允许在同一个钱包内区分比特币账户和其他加密货币账户。

每种货币都有一个唯一的索引，以确保跨多货币钱包的兼容性。例如，对于比特币，索引是$/0'/$（或十六进制表示法中的`0x80000000`）。货币索引在$2^{31}$到$2^{32}-1$的范围内选择，以确保加固派生。

给你其他一些货币的索引示例：

- $1'$（`0x80000001`）用于测试网比特币；
- $2'$（`0x80000002`）用于莱特币；
- $60'$（`0x8000003c`）用于以太坊...

**深度3：账户（BIP32）**

每个钱包可以分为几个账户，从$2^{31}$开始编号，并且在深度3由$/0'/$表示第一个账户，$/1'/$表示第二个，依此类推。通常，当提到扩展密钥`xpub`时，它指的是这个派生深度的密钥。

这种分成不同账户是可选的。它旨在简化用户对钱包的组织。实际上，通常只使用一个账户，通常默认是第一个。然而，在某些情况下，如果希望清楚地区分不同用途的密钥对，这可能是有用的。例如，可以从同一个种子创建一个个人账户和一个专业账户，从这个派生深度拥有完全不同的密钥组。
**深度4：链（BIP32）**
在深度3定义的每个账户接下来被结构化为两条链：

- **外部链**：在这条链上，所谓的“公共”地址被派生。这些接收地址旨在锁定来自外部交易的UTXOs（即，来源于不属于你的UTXOs的消费）。简单地说，每当希望接收比特币时，就使用这个外部链。当你在钱包软件上点击“_接收_”时，总是提供给你一个来自外部链的地址。这条链由一个带有索引$/0/$的密钥对表示。
- **内部链（找零）**：这条链保留用于接收锁定来自你所拥有的UTXOs消费的比特币的地址，换句话说，找零地址。它通过索引$/1/$来识别。

**深度5：地址索引（BIP32）**
最后，深度5代表钱包推导过程中的最后一步。尽管从技术上讲可以无限期地继续下去，但当前标准在此停止。在这个最终深度，将派生出实际用于锁定和解锁UTXOs的密钥对。每个索引允许区分兄弟密钥对：因此，第一个接收地址将使用索引$/0/$，第二个使用索引$/1/$，依此类推。
![CYP201](assets/fr/053.webp)

### 导出路径的表示法

导出路径通过用斜杠($/$)分隔每个级别来书写。因此，每个斜杠都表示从父密钥对($k_{\text{PAR}}$, $K_{\text{PAR}}$, $C_{\text{PAR}}$)到子密钥对($k_{\text{CHD}}$, $K_{\text{CHD}}$, $C_{\text{CHD}}$)的一次派生。在每个深度处标注的数字对应于用于从其父项派生此密钥的索引。索引右侧有时放置的撇号($'$)表示硬化派生($k_{\text{CHD}}^h$, $K_{\text{CHD}}^h$)。有时，这个撇号被$h$替换。如果没有撇号或$h$，那么它就是一个正常的派生($k_{\text{CHD}}^n$, $K_{\text{CHD}}^n$)。
正如我们在前几章中看到的，硬化密钥索引从$2^{31}$开始，或者在十六进制中是`0x80000000`。因此，当导出路径中的索引后跟一个撇号时，必须将$2^{31}$加到指定的数字上，以获得在HMAC-SHA512函数中使用的实际值。例如，如果导出路径指定$/44'/$，实际索引将是：


$$

i = 44 + 2^{31} = 2\,147\,483\,692

$$

在十六进制中，这是`0x8000002C`。

现在我们已经理解了导出路径的主要原则，让我们来看一个例子！这是一个比特币接收地址的导出路径：


$$

m / 84' / 0' / 1' / 0 / 7

$$

在这个例子中：

- $84'$ 表示P2WPKH (SegWit v0)标准；
- $0'$ 表示主网上的比特币货币；
- $1'$ 对应钱包中的第二个账户；
- $0$ 表示地址位于外部链上；
- $7$ 表示此账户的第8个外部地址。

### 导出结构的总结

| 深度 | 描述     | 标准示例                     |
| ---- | -------- | ---------------------------- |
| 0    | 主密钥   | $m/$                         |
| 1    | 目的     | $/86'/$ (P2TR)               |
| 2    | 货币     | $/0'/$ (比特币)              |
| 3    | 账户     | $/0'/$ (第一个账户)          |
| 4    | 链       | $/0/$ (外部) 或 $/1/$ (找零) |
| 5    | 地址索引 | $/0/$ (第一个地址)           |

在下一章中，我们将探索什么是“_输出脚本描述符_”，这是比特币核心中最近引入的一项创新，它简化了比特币钱包的备份过程。

## 输出脚本描述符

<chapterId>e4f1c2d3-9b8a-4d3e-8f2a-7b6c5d4e3f2a</chapterId>
人们常说，助记词短语本身就足以恢复对钱包的访问。实际上，情况稍微复杂一些。在前一章中，我们查看了HD钱包的派生结构，你可能已经注意到这个过程相当复杂。派生路径告诉软件哪个方向去派生用户的密钥。然而，在恢复比特币钱包时，如果不知道这些路径，仅凭助记词短语是不够的。它允许获取主密钥和主链代码，但接下来需要知道用于达到子密钥的索引。

理论上，我们需要保存的不仅是我们钱包的助记词短语，还有我们使用的账户的路径。实际上，即使没有这些信息，只要遵循了标准，通常也有可能重新获得对子密钥的访问权限。通过逐一测试每个标准，通常可以重新获得比特币的访问权限。然而，这并不是保证的，对于初学者来说尤其复杂。此外，随着脚本类型的多样化和更复杂配置的出现，这些信息可能变得难以推断，从而将这些数据变成私人信息，难以通过暴力破解恢复。这就是为什么最近引入了一项创新，并开始被集成到您最喜欢的钱包软件中：_输出脚本描述符_。

### 什么是“描述符”？

“_输出脚本描述符_”，或简称“_描述符_”，是结构化的表达式，完全描述了一个输出脚本（_scriptPubKey_）并提供了跟踪与特定脚本相关的交易所需的所有信息。它们通过提供钱包结构和使用的地址类型的标准化和完整描述，促进了HD钱包中密钥的管理。

描述符的主要优势在于它们能够将恢复钱包所需的所有基本信息封装在单个字符串中（除了恢复短语）。通过保存与助记词短语相关联的描述符，就有可能准确知道它们在层次结构中的位置，从而恢复私钥。对于最初备份更复杂的多签钱包，描述符包括了每个因素的`xpub`，从而确保了在出现问题时重新生成地址的可能性。

### 描述符的构造

描述符由几个元素组成：

- 脚本函数，如`pk`（_支付到公钥_）、`pkh`（_支付到公钥哈希_）、`wpkh`（_支付到见证公钥哈希_）、`sh`（_支付到脚本哈希_）、`wsh`（_支付到见证脚本哈希_）、`tr`（_支付到Taproot_）、`multi`（_多重签名_）和`sortedmulti`（_排序密钥的多重签名_）；
- 派生路径，例如，`[d34db33f/44h/0h/0h]`，它指示了一个派生账户路径和一个特定的主密钥指纹；
- 各种格式的密钥，如十六进制公钥或扩展公钥（`xpub`）；
- 一个校验和，前面有一个哈希符号，用于验证描述符的完整性。
  例如，一个P2WPKH（SegWit v0）钱包的描述符可能看起来像这样：

```text
wpkh([cdeab12f/84h/0h/0h]xpub6CUGRUonZSQ4TWtTMmzXdrXDtyPWKiKbERr4d5qkSmh5h17C1TjvMt7DJ9Qve4dRxm91CDv6cNfKsq2mK1rMsJKhtRUPZz7MQtp3y6atC1U/<0;1>/*)#jy0l7nr4
```

在这个描述符中，派生函数`wpkh`表示一个脚本类型 _向见证公钥哈希支付_。它后面跟着的派生路径包含：

- `cdeab12f`：主密钥指纹；
- `84h`：表示使用BIP84目的，用于SegWit v0地址；
- `0h`：表示这是主网上的BTC货币；
- `0h`：指的是钱包中使用的特定账户号。

描述符还包括在这个钱包中使用的扩展公钥：

```text
xpub6CUGRUonZSQ4TWtTMmzXdrXDtyPWKiKbERr4d5qkSmh5h17C1TjvMt7DJ9Qve4dRxm91CDv6cNfKsq2mK1rMsJKhtRUPZz7MQtp3y6atC1U
```

接下来，符号`/<0;1>/*`指定描述符可以从外部链（`0`）和内部链（`1`）生成地址，其中通配符（`*`）允许以可配置的方式顺序派生多个地址，类似于在传统钱包软件上管理“间隙限制”。
最后，`#jy0l7nr4`代表用于验证描述符完整性的校验和。
现在，您已经了解了比特币HD钱包的操作以及密钥对派生过程。然而，在最后几章中，我们仅限于生成私钥和公钥，没有讨论接收地址的构建。这将正是下一章的主题！

## 接收地址

<chapterId>ca80a89d-f8da-4e09-8c35-43179b65bced</chapterId>

接收地址是嵌入在*scriptPubKey*中的信息片段，用于锁定新创建的UTXOs。简单来说，地址用于接收比特币。让我们探索它们的操作，以及它们与我们在前几章中学习的内容的关联。

### 比特币地址在脚本中的作用

如前所述，交易的作用是将比特币的所有权从输入转移到输出。这个过程涉及消耗UTXOs作为输入，同时创建新的UTXOs作为输出。这些UTXOs由脚本保护，这些脚本定义了解锁资金所需的条件。
当用户接收到比特币时，发送者会创建一个输出UTXO并用*scriptPubKey*对其进行锁定。这个脚本包含了通常指定的规则，比如解锁这个UTXO所需的签名和公钥。为了在新的交易中花费这个UTXO，用户必须通过*scriptSig*提供所请求的信息。*scriptSig*与*scriptPubKey*的执行组合必须返回“true”或`1`。如果满足这个条件，UTXO就可以被花费来创建一个新的UTXO，它本身被一个新的*scriptPubKey*锁定，依此类推。
![CYP201](assets/fr/054.webp)

正是在*scriptPubKey*中找到接收地址。然而，它们的使用根据采用的脚本标准而有所不同。这里是一个根据使用的标准，*scriptPubKey*中包含的信息以及解锁*scriptPubKey*所需的*scriptSig*中期望的信息的总结表格。

| 标准            | _scriptPubKey_                                              | _scriptSig_             | _赎回脚本_       | _见证_                       |
| --------------- | ----------------------------------------------------------- | ----------------------- | ---------------- | ---------------------------- |
| P2PK            | `<pubkey> OP_CHECKSIG`                                      | `<签名>`                |                  |                              |
| P2PKH           | `OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG` | `<签名> <公钥>`         |                  |                              |
| P2SH            | `OP_HASH160 <scriptHash> OP_EQUAL`                          | `<数据推送> <赎回脚本>` | 任意数据         |                              |
| P2WPKH          | `0 <pubKeyHash>`                                            |                         |                  | `<签名> <公钥>`              |
| P2WSH           | `0 <见证脚本哈希>`                                          |                         |                  | `<数据推送> <见证脚本>`      |
| P2SH-P2WPKH     | `OP_HASH160 <赎回脚本哈希> OP_EQUAL`                        | `<赎回脚本>`            | `0 <pubKeyHash>` | `<签名> <公钥>`              |
| P2SH-P2WSH      | `OP_HASH160 <赎回脚本哈希> OP_EQUAL`                        | `<赎回脚本>`            | `0 <脚本哈希>`   | `<数据推送> <见证脚本>`      |
| P2TR (密钥路径) | `1 <公钥>`                                                  |                         |                  | `<签名>`                     |
| P2TR (脚本路径) | `1 <公钥>`                                                  |                         |                  | `<数据推送> <脚本> <控制块>` |

_来源：比特币核心PR审查俱乐部，2021年7月7日 - Gloria Zhao_

脚本中使用的操作码旨在操纵信息，并在必要时进行比较或测试。以P2PKH脚本为例，其格式如下：

```text
OP_DUP OP_HASH160 OP_PUSHBYTES_20 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
```

正如我们将在本章中看到的，`<pubKeyHash>`实际上代表了用于锁定UTXO的接收地址的有效载荷。要解锁这个*scriptPubKey*，就必须提供包含以下内容的*scriptSig*：

```text
<签名> <公钥>
```

在脚本语言中，“栈”是一种“_LIFO_”（“_后进先出_”）数据结构，用于在脚本执行期间临时存储元素。每个脚本操作都会操纵这个栈，元素可以被添加（_push_）或移除（_pop_）。脚本使用这些栈来评估表达式、存储临时变量和管理条件。
我刚刚给出的脚本执行过程遵循以下流程：

- 我们有*scriptSig*、*ScriptPubKey*和栈：

![CYP201](assets/fr/055.webp)

- *scriptSig*被推送到栈上：

![CYP201](assets/fr/056.webp)

- `OP_DUP`在栈上复制*scriptSig*中提供的公钥：

![CYP201](assets/fr/057.webp)

- `OP_HASH160`返回刚刚复制的公钥的哈希值：

![CYP201](assets/fr/058.webp)

- `OP_PUSHBYTES_20 <pubKeyHash>`将包含在*scriptPubKey*中的比特币地址推送到栈上：

![CYP201](assets/fr/059.webp)

- `OP_EQUALVERIFY`验证哈希后的公钥是否与提供的接收地址匹配：

![CYP201](assets/fr/060.webp)
`OP_CHECKSIG`使用公钥检查*scriptSig*中包含的签名。这个操作码本质上执行了我们在本培训第3部分描述的签名验证：
![CYP201](assets/fr/061.webp)

- 如果栈上剩下`1`，则脚本有效：

![CYP201](assets/fr/062.webp)

因此，总结来说，这个脚本允许通过数字签名的帮助，验证声称拥有此UTXO并希望花费它的用户确实拥有与创建此UTXO时使用的接收地址关联的私钥。

### 比特币地址的不同类型

随着比特币的发展，增加了几种标准脚本模型。每种模型都使用不同类型的接收地址。以下是迄今为止可用的主要脚本模型概览：

**P2PK（_支付到公钥_）**：

这种脚本模型由中本聪在比特币的第一个版本中引入。P2PK脚本直接使用原始公钥锁定比特币（因此，这种模型不使用接收地址）。其结构简单：它包含一个公钥，并需要一个相应的数字签名来解锁资金。这个脚本是“_传统_”标准的一部分。

**P2PKH（_支付到公钥哈希_）**：

像P2PK一样，P2PKH脚本在比特币启动时引入。与其前身不同，它通过使用公钥的哈希而不是直接使用原始公钥来锁定比特币。*scriptSig*必须提供与接收地址关联的公钥以及有效的签名。对应于这种模型的地址以`1`开头，并采用*base58check*编码。这个脚本也属于“_传统_”标准。

**P2SH（_支付到脚本哈希_）**：
2012年引入的BIP16中的P2SH模型允许使用任意脚本的哈希值在*scriptPubKey*中。这个被称为“_redeemScript_”的哈希脚本，包含了解锁资金的条件。要花费一个用P2SH锁定的UTXO，需要提供一个包含原始*redeemScript*以及验证它所需数据的*scriptSig*。这个模型特别用于旧的多签名。与P2SH相关的地址以`3`开头，并采用*base58check*编码。这种脚本也属于“_Legacy_”标准。
**P2WPKH（_向见证公钥哈希支付_）**：
这种脚本类似于P2PKH，因为它也通过使用公钥的哈希值来锁定比特币。然而，与P2PKH不同的是，*scriptSig*被移到了一个称为“_Witness_”的单独部分。有时这被称为“_scriptWitness_”，以表示包含签名和公钥的集合。每个SegWit输入都有自己的*scriptWitness*，而*scriptWitnesses*的集合构成了交易的*Witness*字段。这种签名数据的移动是SegWit更新引入的创新，特别旨在防止由于ECDSA签名而导致的交易可变性。
P2WPKH地址使用*bech32*编码，始终以`bc1q`开头。这种类型的脚本对应于版本0的SegWit输出。

**P2WSH（_向见证脚本哈希支付_）**：

P2WSH模型也是在2017年8月的SegWit更新中引入的。类似于P2SH模型，它通过使用脚本的哈希值来锁定比特币。主要区别在于签名和脚本如何并入交易中。要花费用这种类型的脚本锁定的比特币，接收者必须提供原始脚本，称为*witnessScript*（相当于P2SH中的*redeemScript*），以及验证这个*witnessScript*所需的数据。这种机制允许实现更复杂的花费条件，如多签名。

P2WSH地址使用*bech32*编码，始终以`bc1q`开头。这种脚本也对应于版本0的SegWit输出。

**P2TR（_向Taproot支付_）**：

P2TR模型是在2021年11月实施Taproot时引入的。它基于Schnorr协议进行加密密钥聚合，以及基于一个称为MAST（_Merkelized Alternative Script Tree_）的替代脚本的Merkle树。与其他类型的脚本不同，其中花费条件公开暴露（在接收或花费时），P2TR允许在单一的明显公钥后隐藏复杂脚本。

技术上，P2TR脚本通过一个独特的Schnorr公钥$Q$锁定比特币。这个键$Q$实际上是公钥$P$和从*scriptPubKey*的Merkle根计算出的公钥$M$的聚合。用这种类型的脚本锁定的比特币可以通过两种方式花费：

- 为公钥$P$发布一个签名（_key path_）。
- 满足Merkle树中包含的一个脚本（_script path_）。
  P2TR因此提供了极大的灵活性，因为它允许使用唯一的公钥、多个选择的脚本或同时使用两者来锁定比特币。这种默克尔树结构的优势在于，交易过程中只有使用的支出脚本被揭示，而所有其他备选脚本保持秘密。

![CYP201](assets/fr/063.webp)

P2TR对应于版本1的SegWit输出，这意味着P2TR输入的签名存储在交易的*Witness*部分，而不是*scriptSig*中。P2TR地址使用*bech32m*编码，并以`bc1p`开头，但它们非常独特，因为它们不使用哈希函数进行构建。实际上，它们直接代表公钥$Q$，仅以元数据格式化。因此，这是一种接近P2PK的脚本模型。

现在我们已经介绍了理论，让我们进入实践！在接下来的章节中，我提议从一对密钥派生出SegWit v0地址和SegWit v1地址。

## 地址派生

<chapterId>3ebdc750-4135-4881-b07e-08965941b93e</chapterId>

让我们一起探索如何从位于HD钱包第5层的一对密钥生成接收地址。然后，这个地址可以在钱包软件中用来锁定UTXO。

由于生成地址的过程取决于采用的脚本模型，让我们专注于两个特定的案例：在P2WPKH中生成SegWit v0地址和在P2TR中生成SegWit v1地址。这两种类型的地址覆盖了当今的绝大多数用途。

### 公钥压缩

在使用适当的索引从主密钥到第5层执行所有派生步骤后，我们获得一对密钥($k$, $K$)，其中$K = k \cdot G$。虽然可以直接使用这个公钥按照P2PK标准锁定资金，但这不是我们的目标。相反，我们的目标是首先在P2WPKH中创建一个地址，然后在P2TR中创建另一个示例地址。

第一步是压缩公钥$K$。为了好好理解这个过程，让我们首先回顾第3部分介绍的一些基础知识。
比特币上的公钥是椭圆曲线上的一个点$K$。它以$(x, y)$的形式表示，其中$x$和$y$是点的坐标。在未压缩的形式下，这个公钥占用520位：8位前缀（初始值为`0x04`），256位用于$x$坐标，以及256位用于$y$坐标。
然而，椭圆曲线对于x轴具有对称性：对于给定的$x$坐标，$y$只有两个可能的值：$y$和$-y$。这两个点位于x轴的两侧。换句话说，如果我们知道$x$，只需指定$y$是偶数还是奇数就足以确定曲线上的确切点。

![CYP201](assets/fr/064.webp)

为了压缩公钥，只编码 $x$，它占用256位，并添加一个前缀来指定 $y$ 的奇偶性。这种方法将公钥的大小减少到264位，而不是最初的520位。前缀 `0x02` 表示 $y$ 是偶数，而前缀 `0x03` 表示 $y$ 是奇数。
让我们通过一个例子来更好地理解，这里有一个未压缩表示的原始公钥：

```text
K = 04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f
```

如果我们分解这个密钥，我们有：

- 前缀：`04`;
- $x$：`678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb6`;
- $y$：`49f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f`

$y$ 的最后一个十六进制字符是 `f`。在十进制中，`f = 15`，对应一个奇数。因此，$y$ 是奇数，前缀将是 `0x03` 来指示这一点。

压缩后的公钥变为：

```text
K = 03678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb6
```

这个操作适用于所有基于ECDSA的脚本模型，即除了P2TR使用Schnorr之外的所有模型。在Schnorr的情况下，如第3部分所解释的，我们只保留 $x$ 的值，不添加前缀来指示 $y$ 的奇偶性，与ECDSA不同。这是通过为所有密钥任意选择一个唯一的奇偶性来实现的。这允许稍微减少存储公钥所需的空间。

### 派生SegWit v0（bech32）地址

现在我们已经获得了压缩公钥，我们可以从中派生一个SegWit v0接收地址。

第一步是将HASH160哈希函数应用于压缩公钥。HASH160是两个连续哈希函数的组合：SHA256，然后是RIPEMD160：


$$

\text{HASH160}(K) = \text{RIPEMD160}(\text{SHA256}(K))

$$

首先，我们通过SHA256传递密钥：

```text
SHA256(K) = C489EBD66E4103B3C4B5EAFF462B92F5847CA2DCE0825F4997C7CF57DF35BF3A
```

然后我们将结果通过RIPEMD160传递：

```text
RIPEMD160(SHA256(K)) = 9F81322CC88622CA4CCB2A52A21E2888727AA535
```

我们已经获得了公钥的160位哈希值，这构成了所谓的地址的有效载荷（payload）。这个有效载荷代表了地址中最核心和最重要的部分。它也用于*scriptPubKey*中以锁定UTXOs。
然而，为了使这个有效载荷更容易被人类使用，会向其中添加元数据。下一步涉及将这个哈希编码成5位一组的十进制数。这种十进制转换对于转换成*bech32*非常有用，*bech32*被后续的SegWit地址所使用。因此，160位的二进制哈希被划分为32组5位：

$$
\begin{array}{|c|c|}
\hline
\text{5 bits} & \text{Decimal} \\
\hline
10011 & 19 \\
11110 & 30 \\
00000 & 0 \\
10011 & 19 \\
00100 & 4 \\
01011 & 11 \\
00110 & 6 \\
01000 & 8 \\
10000 & 16 \\
11000 & 24 \\
10001 & 17 \\
01100 & 12 \\
10100 & 20 \\
10011 & 19 \\
00110 & 6 \\
01011 & 11 \\
00101 & 5 \\
01001 & 9 \\
01001 & 9 \\
01010 & 10 \\
00100 & 4 \\
00111 & 7 \\
10001 & 17 \\
01000 & 8 \\
10001 & 17 \\
00001 & 1 \\
11001 & 25 \\
00111 & 7 \\
10101 & 21 \\
00101 & 5 \\
00101 & 5 \\
10101 & 21 \\
\hline
\end{array}
$$

因此，我们得到：

```text
HASH = 19 30 00 19 04 11 06 08 16 24 17 12 20 19 06 11 05 09 09 10 04 07 17 08 17 01 25 07 21 09 09 21
```

一旦哈希被编码成5位一组，就会向地址添加一个校验和。这个校验和用于验证地址的有效载荷在存储或传输过程中没有被更改。例如，它允许钱包软件确保你在输入接收地址时没有打错字。没有这种验证，你可能会不小心将比特币发送到一个错误的地址，导致资金的永久损失，因为你不拥有相关的公钥或私钥。因此，校验和是防止人为错误的一种保护。

对于旧的比特币*Legacy*地址，校验和仅仅是从地址哈希的开始使用HASH256函数计算得出的。随着SegWit和*bech32*格式的引入，现在使用BCH码（_Bose, Ray-Chaudhuri, 和 Hocquenghem_）。这些纠错码用于检测和纠正数据序列中的错误。它们确保传输的信息即使在轻微更改的情况下也能完整地到达目的地。BCH码在许多领域都有应用，如SSD、DVD和QR码。例如，多亏了这些BCH码，即使部分遮挡的QR码仍然可以被读取和解码。

在比特币的背景下，与用于*Legacy*地址的简单哈希函数相比，BCH码提供了更好的尺寸和错误检测能力之间的折衷。然而，在比特币上，BCH码仅用于错误检测，而不是纠正。因此，钱包软件会标记出不正确的接收地址，但不会自动纠正它。这种限制是故意的：允许自动纠正会降低错误检测能力。

为了使用BCH码计算校验和，我们需要准备几个元素：

- **人类可读部分（HRP）**：对于比特币主网，HRP是`bc`；
  HRP必须通过将每个字符分成两部分来扩展：
- 以ASCII码取HRP的字符：
  - `b`：`01100010`
- `c`：`01100011`
- 提取3个最重要位和5个最不重要位：
  - 3个最重要位：`011`（十进制中的3）
  - 3个最重要位：`011`（十进制中的3）
  - 5个最不重要位：`00010`（十进制中的2）
  - 5个最不重要位：`00011`（十进制中的3）

使用`0`作为两个字符之间的分隔符，因此HRP扩展为：

```text
03 03 00 02 03
```

- **见证版本**：对于SegWit版本0，它是`00`；

- **有效载荷**：公钥哈希的十进制值；

- **为校验和保留**：在序列末尾添加6个零`[0, 0, 0, 0, 0, 0]`。

所有组合数据输入到程序中以计算校验和如下：

```text
HRP = 03 03 00 02 03
SEGWIT v0 = 00
HASH = 19 30 00 19 04 11 06 08 16 24 17 12 20 19 06 11 05 09 09 10 04 07 17 08 17 01 25 07 21 09 09 21
CHECKSUM = 00 00 00 00 00 00

INPUT = 03 03 00 02 03 00 19 30 00 19 04 11 06 08 16 24 17 12 20 19 06 11 05 09 09 10 04 07 17 08 17 01 25 07 21 09 09 21 00 00 00 00 00 00
```

校验和的计算相当复杂。它涉及到多项式有限域算术。我们在这里不详细介绍这个计算，直接进入结果。在我们的例子中，以十进制得到的校验和是：

```text
10 16 11 04 13 18
```

我们现在可以通过按顺序连接以下元素来构造接收地址：

- **SegWit版本**：`00`
- **有效载荷**：公钥哈希
- **校验和**：上一步获得的值（`10 16 11 04 13 18`）

这给我们以十进制表示为：

```text
00 19 30 00 19 04 11 06 08 16 24 17 12 20 19 06 11 05 09 09 10 04 07 17 08 17 01 25 07 21 09 09 21 10 16 11 04 13 18
```

然后，每个十进制值必须使用以下转换表映射到其*bech32*字符：


$$
\begin{array}{|c|c|c|c|c|c|c|c|c|}
\hline
 & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
\hline
+0 & q & p & z & r & y & 9 & x & 8 \\
\hline
+8 & g & f & 2 & t & v & d & w & 0 \\
\hline
+16 & s & 3 & j & n & 5 & 4 & k & h \\
\hline
+24 & c & e & 6 & m & u & a & 7 & l \\
\hline
\end{array}
$$

要将一个值转换为 _bech32_ 字符，只需在第一列和第一行中找到相加后能得到所需结果的值。然后，检索相应的字符。例如，十进制数 `19` 将被转换为字母 `n`，因为 $19 = 16 + 3$。
通过映射我们所有的值，我们得到以下地址：

```
qn7qnytxgsc3v5nxt9ff2y83g3pe849942stydj
```

剩下的就是添加 HRP `bc`，它表示这是一个比特币主网的地址，以及分隔符 `1`，以获得完整的接收地址：

```
bc1qn7qnytxgsc3v5nxt9ff2y83g3pe849942stydj
```

这个 _bech32_ 字母表的特点是，它包含了所有的字母数字字符，除了 `1`、`b`、`i` 和 `o`，以避免在人类输入或阅读时相似字符之间的视觉混淆。

总结一下，这是推导过程：

![CYP201](assets/fr/065.webp)

这就是如何从一对密钥推导出 P2WPKH (SegWit v0) 接收地址。现在让我们继续了解 P2TR (SegWit v1 / Taproot) 地址的生成过程。

### SegWit v1 (bech32m) 地址的推导

对于 Taproot 地址，生成过程略有不同。让我们一起看看！

从公钥压缩步骤开始，与 ECDSA 相比出现了第一个区别：用于比特币上的 Schnorr 的公钥仅由其横坐标 ($x$) 表示。因此，没有前缀，压缩后的密钥正好是 256 位。
正如我们在前一章中看到的，P2TR 脚本通过一个独特的 Schnorr 公钥锁定比特币，由 $Q$ 表示。这个密钥 $Q$ 是两个公钥的聚合：$P$，一个主内部公钥，和 $M$，一个从 _scriptPubKey_ 的 Merkle 根派生的公钥列表中派生的公钥。用这种类型的脚本锁定的比特币可以通过两种方式花费：

- 通过为公钥 $P$ 发布一个签名（_密钥路径_）；
- 通过满足 Merkle 树中包含的一个脚本（_脚本路径_）。

实际上，这两个密钥并不是真正的“聚合”。密钥 $P$ 而是通过密钥 $M$ 被调整（tweaked）。在密码学中，"调整"（tweak）一个公钥意味着通过应用一个称为“调整值”的加法值来修改这个密钥。这个操作允许修改后的密钥与原始私钥和调整值保持兼容。技术上，调整值是一个标量值 $t$，它被添加到初始公钥上。如果 $P$ 是原始公钥，调整后的密钥变为：

$$

P' = P + tG


$$

其中 $G$ 是所使用的椭圆曲线的生成元。这个操作产生了一个从原始密钥派生的新公钥，同时保留了允许其使用的密码学属性。
如果您不需要添加备用脚本（仅通过*关键路径*进行消费），您可以仅基于钱包深度为5处的公钥生成一个Taproot地址。在这种情况下，需要为*脚本路径*创建一个不可消费的脚本，以满足结构的要求。然后通过在内部公钥$P$上应用一个带标签的哈希函数**`TapTweak`**来计算调整值$t$：

$$

t = \text{H}\_{\text{TapTweak}}(P)


$$

其中：

- **$\text{H}_{\text{TapTweak}}$** 是一个带有`TapTweak`标签的SHA256哈希函数。如果您不熟悉什么是带标签的哈希函数，我邀请您参考第3.3章；
- $P$ 是内部公钥，以其压缩的256位格式表示，仅使用$x$坐标。

然后通过将调整值$t$乘以椭圆曲线生成器$G$，加到内部公钥$P$上，计算Taproot公钥$Q$：

$$

Q = P + t \cdot G


$$

一旦获得Taproot公钥$Q$，我们就可以生成相应的接收地址。与其他格式不同，Taproot地址不是基于公钥的哈希建立的。因此，密钥$Q$直接以原始方式插入到地址中。

首先，我们提取点$Q$的$x$坐标以获得一个压缩公钥。在这个有效载荷上，使用BCH码计算校验和，就像SegWit v0地址一样。然而，用于Taproot地址的程序略有不同。实际上，在引入SegWit的*bech32*格式后，发现了一个错误：当一个地址的最后一个字符是`p`时，在这个`p`之前插入或移除`q`并不会使校验和无效。尽管这个错误对SegWit v0没有影响（感谢大小限制），但在未来可能会构成问题。因此，这个错误已经为Taproot地址得到了纠正，新的纠正格式被称为"_bech32m_"。

Taproot地址通过以下元素以*bech32m*格式编码$Q$的$x$坐标生成：

- **人类可读部分（HRP）**：`bc`，表示主比特币网络；
- **版本**：`1`表示Taproot / SegWit v1；
- **校验和**。

最终地址将具有以下格式：

```
bc1p[Qx][校验和]
```

另一方面，如果您希望除了使用内部公钥（_脚本路径_）进行消费外，还添加备用脚本，接收地址的计算将略有不同。您需要在调整值的计算中包含备用脚本的哈希。在Taproot中，位于Merkle树末端的每个备用脚本被称为一个“叶子”。

一旦编写了不同的备用脚本，您必须通过带标签的哈希函数`TapLeaf`逐个传递它们，附带一些元数据：

$$

\text{h}_{\text{leaf}} = \text{H}_{\text{TapLeaf}} (v \Vert sz \Vert S)


$$

其中：

- $v$：脚本版本号（Taproot的默认值为`0xC0`）；
- $sz$：脚本大小，以*CompactSize*格式编码；
- $S$：脚本。

不同的脚本哈希（$\text{h}_{\text{leaf}}$）首先按字典顺序排序。然后，它们成对连接，并通过标记哈希函数`TapBranch`进行处理。这个过程反复迭代，逐步构建Merkle树：
$$
\text{h}_{\text{branch}} = \text{H}_{\text{TapBranch}}(\text{h}_{\text{leaf1}} \Vert \text{h}_{\text{leaf2}})
$$

然后，我们继续两两连接结果，每一步都通过标记哈希函数`TapBranch`处理，直到我们获得Merkle树的根：

![CYP201](assets/fr/066.webp)

在计算出梅克尔根 $h_{\text{root}}$ 之后，我们可以计算 tweak。为此，将钱包的内部公钥 $P$ 与根 $h_{\text{root}}$ 连接，并将结果通过标记哈希函数 `TapTweak`：

$$
t = \text{H}_{\text{TapTweak}}(P \Vert h_{\text{root}})
$$

最后，与之前一样，Taproot 公钥 $Q$ 是通过将内部公钥 $P$ 与 tweak $t$ 和生成点 $G$ 的乘积相加获得的：

$$
Q = P + t \cdot G
$$

然后，地址生成遵循相同的流程，使用原始公钥 $Q$ 作为有效载荷，并附加一些额外的元数据。


就这样！我们已经完成了CYP201课程的学习。如果您觉得这门课程有帮助，我将非常感激您能在接下来的评估章节给予好评。也欢迎您与亲朋好友分享，或在您的社交网络上分享。最后，如果您希望获得这门课程的毕业证书，可以在评估章节之后参加最终考试。

# 结论

<partId>58111408-b734-54db-9ea7-0d5b67f99f99</partId>

## 评价此课程

<chapterId>0cd71541-a7fd-53db-b66a-8611b6a28b04</chapterId>
<isCourseReview>true</isCourseReview>

## 期末考试

<chapterId>a53ea27d-0f84-56cd-b37c-a66210a4b31d</chapterId>
<isCourseExam>true</isCourseExam>

## 结论

<chapterId>d291428b-3cfa-5394-930e-4b514be82d5a</chapterId>

我们已经到达CYP201培训的尾声。希望这次培训对您的比特币学习之旅有所帮助，让您更好地理解您日常使用的HD钱包的工作原理。感谢您坚持学完本课程！

在我看来，这些关于钱包的知识是基础性的，因为它将比特币的理论方面与实际应用联系起来。事实上，如果您使用比特币，就必然要处理钱包软件。了解它们的内部运作机制使您能够实施有效的安全策略，同时掌握基本机制、风险和潜在弱点。这样，您就能更安全、更自信地使用比特币。

如果您还没有这样做，我邀请您对这次培训进行评价和评论。这将对我有很大帮助。您也可以在社交网络上分享这个培训，让更多的人获得这些知识。

要继续深入探索，我强烈推荐我在Plan ₿ Network上制作的**BTC204**培训。它专注于比特币隐私，探讨关键主题：什么是隐私模型？链分析是如何工作的？如何优化使用比特币以最大化您的隐私？这是深化您技能的合理下一步！

https://planb.network/courses/btc204

此外，为了继续深化您在比特币领域的知识，我们邀请您探索Plan ₿ Network上的其他课程，如：

#### 学习如何创建您的比特币社区

https://planb.network/courses/btc302

#### 探索闪电网络

https://planb.network/courses/lnp201

#### 探索奥地利学派的经济思想

https://planb.network/courses/eco201

#### 探索比特币起源的历史

https://planb.network/courses/his201

#### 探索自由在历史长河中的演变

https://planb.network/courses/phi201




