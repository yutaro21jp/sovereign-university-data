---
name: Bitcoinウォレットの内部構造
goal: Bitcoinウォレットを動かす暗号学的原理を深く掘り下げる。
objectives:
  - Bitcoinで使用される暗号アルゴリズムを理解するために必要な理論的概念を定義する。
  - 決定論的かつ階層的なウォレットの構造を完全に理解する。
  - ウォレットの管理に関連するリスクを特定し、軽減する方法を知る。
  - ハッシュ関数、暗号鍵、デジタル署名の原理を理解する。
---

# Bitcoinウォレットの核心への旅

CYP201コースで、決定論的かつ階層的なBitcoinウォレットの秘密を解き明かしましょう！日常的なユーザーであれ、知識を深めたい熱心な愛好家であれ、このコースは、私たちが毎日使用しているこれらのツールの仕組みに完全に没入する機会を提供します。

ハッシュ関数、デジタル署名（ECDSAおよびSchnorr）、ニーモニックフレーズ、暗号鍵、受信アドレスの作成のメカニズムについて学びながら、高度なセキュリティ戦略を探求します。

このトレーニングは、Bitcoinウォレットの構造を理解するための知識を装備するだけでなく、暗号学のエキサイティングな世界へさらに深く潜る準備を整えます。

明確な教育法、60以上の説明図、具体的な例を用いて、CYP201はあなたのウォレットがどのように機能するかをAからZまで理解することを可能にし、Bitcoinの宇宙を自信を持ってナビゲートできるようにします。HDウォレットの機能を理解することで、今日からあなたのUTXOをコントロールしましょう！

+++

# 導入

<partId>32960669-d13a-592f-a053-37f70b997cbf</partId>

## コースの紹介

<chapterId>fb4e8857-ea35-5a8a-ae8a-5300234e0104</chapterId>

HD Bitcoinウォレットの仕組みを深く探求するCYP201コースへようこそ。このコースは、Bitcoinの技術的な基礎を理解したいと思っている誰にでも向けて設計されています。それが日常的なユーザーであれ、啓蒙された愛好家であれ、または将来の専門家であれ。

このトレーニングの目標は、あなたが日常的に使用しているツールをマスターするための鍵を提供することです。あなたのユーザー体験の中心にあるHD Bitcoinウォレットは、時に複雑な概念に基づいていますが、私たちはそれらをアクセスしやすくしようと試みます。一緒に、それらを解明しましょう！

Bitcoinウォレットの構造と運用の詳細に飛び込む前に、続くために知っておくべき暗号プリミティブについていくつかの章から始めます。
まず、ウォレットとBitcoinプロトコル自体の両方にとって基本的な暗号ハッシュ関数について学びます。その主な特徴、Bitcoinで使用される特定の関数、そしてより技術的な章では、ハッシュ関数の女王であるSHA256の仕組みについて詳しく学びます。
![CYP201](assets/fr/010.webp)

次に、あなたが毎日UTXOを保護するために使用しているデジタル署名アルゴリズムの運用について話し合います。Bitcoinは2つを使用しています：ECDSAとSchnorrプロトコル。これらのアルゴリズムに基づく数学的プリミティブと、トランザクションのセキュリティをどのように保証するかを学びます。

![CYP201](assets/fr/021.webp)

これらの暗号学の要素をよく理解したら、ついにトレーニングの核心である決定論的かつ階層的ウォレットに移ります！まず、ウォレットを作成および復元するために使用される12または24の単語のシーケンスであるニーモニックフレーズに捧げられたセクションがあります。これらの単語がどのようにエントロピーの源から生成され、Bitcoinの使用をどのように容易にするかを発見します。

![CYP201](assets/fr/040.webp)
このトレーニングでは、BIP39のパスフレーズ、シード（ニーモニックフレーズと混同しないでください）、マスターチェーンコード、およびマスターキーの研究を続けます。これらの要素が何であるか、それぞれの役割、そしてどのように計算されるかを詳しく見ていきます。
![CYP201](assets/fr/045.webp)

最終的に、マスターキーから、受信アドレスまで決定的かつ階層的に派生される暗号鍵ペアの生成方法を発見します。

![CYP201](assets/fr/056.webp)

このトレーニングにより、ウォレットソフトウェアを自信を持って使用できるようになり、リスクを特定し軽減するスキルを向上させることができます。ビットコインウォレットの真のエキスパートになる準備をしてください！

# ハッシュ関数

<partId>3713fee1-2ec2-512e-9e97-b6da9e4d2f17</partId>

## ハッシュ関数への導入

<chapterId>dba011f5-1805-5a48-ac2b-4bd637c93703</chapterId>

ビットコインで使用される最初のタイプの暗号アルゴリズムには、ハッシュ関数が含まれます。これらはプロトコルの異なるレベルだけでなく、ビットコインウォレット内でも重要な役割を果たします。ハッシュ関数が何であり、ビットコインでどのように使用されるかを一緒に見ていきましょう。

### ハッシュ化の定義と原理

ハッシュ化は、任意の長さの情報を暗号ハッシュ関数を通じて固定長の別の情報に変換するプロセスです。言い換えると、ハッシュ関数は任意のサイズの入力を取り、固定サイズの指紋である「ハッシュ」と呼ばれるものに変換します。
ハッシュは、「ダイジェスト」、「コンデンセート」、「凝縮」、または「ハッシュ化された」とも呼ばれることがあります。

例えば、SHA256ハッシュ関数は、256ビットの固定長のハッシュを生成します。したがって、任意の長さのメッセージ「_PlanB_」を入力として使用した場合、生成されるハッシュは以下の256ビットの指紋になります：

```text
24f1b93b68026bfc24f5c8265f287b4c940fb1664b0d75053589d7a4f821b688
```

![CYP201](assets/fr/001.webp)

### ハッシュ関数の特徴

これらの暗号ハッシュ関数には、ビットコインや他のコンピューターシステムの文脈で特に有用であるいくつかの重要な特徴があります：

1. 不可逆性（またはプレイメージ耐性）
2. 改ざん耐性（アバランシェ効果）
3. 衝突耐性
4. セカンドプレイメージ耐性

#### 1. 不可逆性（プレイメージ耐性）：

不可逆性とは、入力情報からハッシュを計算することは容易ですが、逆の計算、つまりハッシュから入力を見つけ出すことは実際には不可能であることを意味します。この特性は、元の情報を妥協することなくユニークなデジタル指紋を作成するために、ハッシュ関数を完璧にします。この特性は、しばしば一方向関数または「_トラップドア関数_」として言及されます。

与えられた例では、「_PlanB_」という入力を知っている場合、ハッシュ`24f1b9…`を得ることは簡単で迅速です。しかし、`24f1b9…`のみを知っている状態でメッセージ「_PlanB_」を見つけ出すことは不可能です。

![CYP201](assets/fr/002.webp)

したがって、ハッシュ$h$に対して、$h = \text{HASH}(m)$であるようなプレイメージ$m$を見つけることは不可能です。ここで、$\text{HASH}$は暗号ハッシュ関数です。

#### 2. 改ざん耐性（アバランシェ効果）

第二の特性は、改ざん耐性、または**アバランシェ効果**としても知られています。この特性は、入力メッセージのわずかな変更が出力ハッシュに根本的な変化をもたらす場合に、ハッシュ関数で観察されます。
例として"_PlanB_"という入力とSHA256関数を振り返ると、生成されたハッシュは以下の通りです：

```text
24f1b93b68026bfc24f5c8265f287b4c940fb1664b0d75053589d7a4f821b688
```

入力を"_Planb_"にわずかに変更すると、大文字の"B"を小文字の"b"に変えるだけで、SHA256の出力ハッシュが完全に変わります：

```text
bb038b4503ac5d90e1205788b00f8f314583c5e22f72bec84b8735ba5a36df3f
```

![CYP201](assets/fr/003.webp)

この特性により、元のメッセージのわずかな変更でも直ちに検出可能であることが保証されます。なぜなら、ハッシュの一部分だけでなく、ハッシュ全体が変更されるからです。これは、メッセージ、ソフトウェア、あるいはビットコイン取引の完全性を検証するために、さまざまな分野で興味深いものです。

#### 3. 衝突耐性

第三の特性は衝突耐性です。ハッシュ関数が衝突耐性を持つとは、関数から同じハッシュ出力を生成する2つの異なるメッセージを見つけることが計算上不可能であることを意味します。正式には、二つの異なるメッセージ$m_1$と$m_2$について、

$$
\text{HASH}(m_1) = \text{HASH}(m_2)
$$

が成り立つような$m_1$と$m_2$を見つけることは困難です。

![CYP201](assets/fr/004.webp)

実際には、入力のサイズが出力のサイズよりも大きくなり得るため、ハッシュ関数には衝突が数学的に避けられないことがあります。これはディリクレの引き出し原理として知られています：$n$個のオブジェクトが$m$個の引き出しに分配される場合、$m < n$であれば、少なくとも1つの引き出しには2つ以上のオブジェクトが必ず含まれます。ハッシュ関数においては、可能なメッセージの数が（ほぼ）無限であるのに対し、可能なハッシュの数は有限（SHA256の場合は$2^{256}$）であるため、この原理が適用されます。

したがって、この特性はハッシュ関数に衝突が存在しないことを意味するのではなく、良いハッシュ関数は衝突を見つける確率を無視できるほど小さくすることを意味します。例えば、SHA-0やSHA-1のようなSHA-2の前身のアルゴリズムでは、衝突が見つかっており、これらの関数は現在、使用が推奨されず、しばしば時代遅れと見なされています。
$n$ビットのハッシュ関数における衝突耐性は、誕生日攻撃に従って、$2^{\frac{n}{2}}$のオーダーです。例えば、SHA256（$n = 256$）の場合、衝突を見つける複雑さは$2^{128}$試行のオーダーです。実際には、$2^{128}$異なるメッセージを関数を通すと、衝突が見つかる可能性があります。

#### 4. 第二事前画像耐性

第二事前画像耐性は、ハッシュ関数のもう一つの重要な特性です。これは、メッセージ$m_1$とそのハッシュ$h$が与えられた場合、$m_2 \neq m_1$である別のメッセージ$m_2$を見つけることが計算上実行不可能であることを述べています：

$$
\text{HASH}(m_1) = \text{HASH}(m_2)
$$

したがって、第二事前画像耐性は衝突耐性に似ていますが、ここでは攻撃がより困難です。なぜなら、攻撃者は$m_1$を自由に選ぶことができないからです。

![CYP201](assets/fr/005.webp)

### Bitcoinにおけるハッシュ関数の応用

Bitcoinで最も使用されているハッシュ関数は**SHA256**（"_Secure Hash Algorithm 256 bits"_）です。この関数は2000年代初頭にNSAによって設計され、NISTによって標準化され、256ビットのハッシュ出力を生成します。

この関数はBitcoinの多くの側面で使用されています。プロトコルレベルでは、Proof-of-Workメカニズムに関与しており、マイナーによって作成された候補ブロックのヘッダーと難易度ターゲットとの間で部分的な衝突を探すために二重ハッシュとして適用されます。この部分的な衝突が見つかると、候補ブロックは有効となり、ブロックチェーンに追加することができます。

SHA256はまた、トランザクションをブロックに記録するために使用されるアキュムレータであるMerkle木の構築にも使用されます。この構造はUtreexoプロトコルにも見られ、UTXOセットのサイズを削減することができます。さらに、2021年にTaprootが導入されたことで、SHA256はMAST（_Merkelised Alternative Script Tree_）においても利用され、スクリプト内で実際に使用される支出条件のみを明らかにし、他の可能なオプションを開示せずに済むようになりました。また、トランザクション識別子の計算、P2Pネットワーク上でのパケットの送信、電子署名などにも使用されます... 最後に、そしてこのトレーニングで特に興味深いことですが、SHA256はBitcoinウォレットの構築やアドレスの導出においてアプリケーションレベルで使用されます。

Bitcoin上でSHA256の使用に遭遇する場合、実際には二重ハッシュSHA256、 "**HASH256**"と表記されることが多く、単純にSHA256を二回連続して適用することを意味します：
HASH256(m) = SHA256(SHA256(m))

この二重ハッシュの実践は、単一のSHA256が今日、暗号学的に安全と考えられているにもかかわらず、特定の潜在的な攻撃に対する追加のセキュリティ層を追加します。

受信アドレスを導出するためにScript言語で利用可能な別のハッシュ関数はRIPEMD160関数です。この関数は160ビットのハッシュ（したがってSHA256より短い）を生成します。一般的に、キーまたはスクリプトハッシュのハッシュを表す特定のBitcoinアドレスの作成、およびキーフィンガープリントの生成に使用される、より短いハッシュを生成するためにSHA256と組み合わせてHASH160関数を形成します：

$$
\text{HASH160}(m) = \text{RIPEMD160}(\text{SHA256}(m))
$$

最後に、アプリケーションレベルでのみ、ウォレットのキー導出に間接的な役割を果たすことがあるSHA512関数も時々使用されます。この関数はその操作においてSHA256と非常に似ています。両方とも同じSHA2ファミリーに属していますが、SHA512はその名が示すように、SHA256の256ビットに比べて512ビットのハッシュを生成します。その使用については、後続の章で詳しく説明します。

これで、これから先についてのハッシュ関数の基本的な知識を知ることができました。次の章では、Bitcoinの中心にある関数、SHA256の仕組みをより詳細に探求しましょう。ここで説明した特性をどのように達成しているかを理解するために、それを解剖します。次の章はかなり長くて技術的ですが、トレーニングの残りの部分をフォローするためには不可欠ではありません。したがって、理解するのが難しい場合は心配せず、はるかにアクセスしやすい次の章に直接進んでください。

## SHA256の内部構造

<chapterId>905eb320-f15b-5fb6-8d2d-5bb447337deb</chapterId>
これまでに、ハッシュ関数がビットコインでの使用を正当化する重要な特性を持っていることを見てきました。今度は、これらの特性を持つ理由となるハッシュ関数の内部メカニズムを詳しく見ていきましょう。そのために、SHA256の動作を解剖することを提案します。
SHA256とSHA512関数は、同じSHA2ファミリーに属しています。そのメカニズムは、**Merkle-Damgård構造**と呼ばれる特定の構造に基づいています。RIPEMD160も、この同じタイプの構造を使用しています。

思い出しておきましょう。SHA256への入力として任意のサイズのメッセージがあり、この関数を通して256ビットのハッシュを出力として得ることになります。

### 入力の前処理

まず、入力メッセージ$m$を512ビットの倍数の標準的な長さにするために準備する必要があります。このステップは、その後のアルゴリズムの適切な機能にとって重要です。
これを行うために、まずパディングビットのステップから始めます。メッセージにセパレータビット`1`を追加し、その後に一定数の`0`ビットを追加します。追加される`0`ビットの数は、この追加後のメッセージの合計長が512で割った余りが448になるように計算されます。したがって、パディングビットを含むメッセージの長さ$L$は次のようになります：

$$
L \equiv 448 \mod 512
$$

$\text{mod}$は、モジュロという数学的演算で、2つの整数の間で、最初の数を2番目の数でユークリッド除算した余りを返します。例えば：$16 \mod 5 = 1$。これは暗号学で広く使用される演算です。

ここで、パディングステップは、次のステップで64ビットを追加した後、等化されたメッセージの合計長が512ビットの倍数になることを保証します。もし初期メッセージが$M$ビットの長さであれば、追加されるべき`0`ビットの数（$N$）は次のようになります：

$$
N = (448 - (M + 1) \mod 512) \mod 512
$$

例えば、初期メッセージが950ビットである場合、計算は以下のようになります：

$$
\begin{align*}
M & = 950 \\
M + 1 & = 951 \\
(M + 1) \mod 512 & = 951 \mod 512 \\
& = 951 - 512 \cdot \left\lfloor \frac{951}{512} \right\rfloor \\
& = 951 - 512 \cdot 1 \\
& = 951 - 512 \\
& = 439 \\
\\
448 - (M + 1) \mod 512 & = 448 - 439 \\
& = 9 \\
\\
N & = (448 - (M + 1) \mod 512) \mod 512 \\
N & = 9 \mod 512 \\
& = 9
\end{align*}
$$

したがって、セパレータ`1`に加えて9つの`0`が追加されます。私たちのメッセージ$M$の直後に追加されるべきパディングビットは次のようになります：

```text
1000 0000 00
```

パディングビットをメッセージ$M$に追加した後、元のメッセージ$M$の長さの64ビット表現を二進数で追加します。これにより、ハッシュ関数はビットの順序とメッセージの長さに敏感になります。
私たちが最初のメッセージが950ビットである例に戻ると、10進数の`950`を2進数に変換し、これにより`1110 1101 10`が得られます。この数値に基底でゼロを補完して合計64ビットにします。私たちの例では、以下のようになります：

```text
0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0011 1011 0110
```

このパディングサイズはビットパディングに従って追加されます。したがって、前処理後のメッセージは3つの部分から構成されます：

1. オリジナルのメッセージ $M$;
2. ビットパディングを形成するためにいくつかのビット `0` に続くビット `1`;
3. $M$の長さの64ビット表現でサイズとともにパディングを形成します。

![CYP201](assets/fr/006.webp)

### 変数の初期化

SHA256は、各32ビットの8つの初期状態変数、$A$から$H$までを使用します。これらの変数は、最初の8つの素数の平方根の小数部分である特定の定数で初期化されます。これらの値は、ハッシュ処理中に後で使用します：

- $A = 0x6a09e667$
- $B = 0xbb67ae85$
- $C = 0x3c6ef372$
- $D = 0xa54ff53a$
- $E = 0x510e527f$
- $F = 0x9b05688c$
- $G = 0x1f83d9ab$
- $H = 0x5be0cd19$

SHA256は、最初の64個の素数の立方根の小数部分である他の64個の定数、$K_0$から$K_{63}$も使用します：

$$
K[0 \ldots 63] = \begin{pmatrix}
0x428a2f98, & 0x71374491, & 0xb5c0fbcf, & 0xe9b5dba5, \\
0x3956c25b, & 0x59f111f1, & 0x923f82a4, & 0xab1c5ed5, \\
0xd807aa98, & 0x12835b01, & 0x243185be, & 0x550c7dc3, \\
0x72be5d74, & 0x80deb1fe, & 0x9bdc06a7, & 0xc19bf174, \\
0xe49b69c1, & 0xefbe4786, & 0x0fc19dc6, & 0x240ca1cc, \\
0x2de92c6f, & 0x4a7484aa, & 0x5cb0a9dc, & 0x76f988da, \\
0x983e5152, & 0xa831c66d, & 0xb00327c8, & 0xbf597fc7, \\
0xc6e00bf3, & 0xd5a79147, & 0x06ca6351, & 0x14292967, \\
0x27b70a85, & 0x2e1b2138, & 0x4d2c6dfc, & 0x53380d13, \\
0x650a7354, & 0x766a0abb, & 0x81c2c92e, & 0x92722c85, \\
0xa2bfe8a1, & 0xa81a664b, & 0xc24b8b70, & 0xc76c51a3, \\
0xd192e819, & 0xd6990624, & 0xf40e3585, & 0x106aa070, \\
0x19a4c116, & 0x1e376c08, & 0x2748774c, & 0x34b0bcb5, \\
0x391c0cb3, & 0x4ed8aa4a, & 0x5b9cca4f, & 0x682e6ff3, \\
0x748f82ee, & 0x78a5636f, & 0x84c87814, & 0x8cc70208, \\
0x90befffa, & 0xa4506ceb, & 0xbef9a3f7, & 0xc67178f2
\end{pmatrix}
$$


### 入力の分割

これで入力を均等化しましたので、SHA256アルゴリズムの主要な処理フェーズである圧縮関数に移ります。このステップは非常に重要で、前章で学んだハッシュ関数の暗号学的特性を主に与えるものです。

まず、前処理ステップの結果である均等化されたメッセージを、それぞれ512ビットの複数のブロック$P$に分割します。均等化されたメッセージが合計で$n \times 512$ビットのサイズを持つ場合、それぞれ512ビットの$n$個のブロックができます。各512ビットブロックは、64ラウンドの連続した操作で構成される圧縮関数によって個別に処理されます。これらのブロックを$P_1$、$P_2$、$P_3$...と名付けましょう。

### 論理演算

圧縮関数を詳細に探る前に、それに使用される基本的な論理演算を理解することが重要です。これらの演算はブール代数に基づいており、ビットレベルで操作します。使用される基本的な論理演算は以下の通りです：

- **論理積（AND）**：$\land$で示され、論理的な「AND」に対応します。
- **論理和（OR）**：$\lor$で示され、論理的な「OR」に対応します。
- **否定（NOT）**：$\lnot$で示され、論理的な「NOT」に対応します。

これらの基本操作から、暗号学で広く使用される「排他的論理和」（XOR）などのより複雑な操作を定義できます。XORは$\oplus$で示されます。
すべての論理操作は、二進入力値（二つのオペランド$p$と$q$）のすべての可能な組み合わせの結果を示す真理値表によって表されます。
XOR（$\oplus$）の場合：

| $p$ | $q$ | $p \oplus q$ |
| --- | --- | ------------ |
| 0   | 0   | 0            |
| 0   | 1   | 1            |
| 1   | 0   | 1            |
| 1   | 1   | 0            |

AND（$\land$）の場合：

| $p$ | $q$ | $p \land q$ |
| --- | --- | ----------- |
| 0   | 0   | 0           |
| 0   | 1   | 0           |
| 1   | 0   | 0           |
| 1   | 1   | 1           |

NOT ($\lnot p$)について:

| $p$ | $\lnot p$ |
| --- | --------- |
| 0   | 1         |
| 1   | 0         |

ビットレベルでのXORの操作を理解するための例を見てみましょう。6ビットの2つのバイナリ数があるとします:

- $a = 101100$
- $b = 001000$

すると:

$$
a \oplus b = 101100 \oplus 001000 = 100100
$$

ビットごとにXORを適用すると:

| ビット位置 | $a$ | $b$ | $a \oplus b$ |
| ---------- | --- | --- | ------------ |
| 1          | 1   | 0   | 1            |
| 2          | 0   | 0   | 0            |
| 3          | 1   | 1   | 0            |
| 4          | 1   | 0   | 1            |
| 5          | 0   | 0   | 0            |
| 6          | 0   | 0   | 0            |

その結果は$100100$となります。

論理演算に加えて、圧縮関数ではビットシフト演算も使用され、これはアルゴリズムでのビットの拡散において重要な役割を果たします。

まず、論理右シフト演算があり、$ShR_n(x)$と表記され、$x$の全ビットを右に$n$位置シフトし、左側の空いたビットをゼロで埋めます。

例えば、$x = 101100001$（9ビット）と$n = 4$の場合:

$$
ShR_4(101100001) = 000010110
$$

概念的に、右シフト演算は以下のように見えます:

![CYP201](assets/fr/007.webp)
SHA256でビット操作に使用される別の演算は、右回りの循環シフトで、$RotR_n(x)$と表記され、$x$のビットを右に$n$位置シフトし、シフトされたビットを文字列の始めに再挿入します。
例えば、$x = 101100001$（9ビット）と$n = 4$の場合:

$$
RotR_4(101100001) = 000110110
$$

概念的に、右回りの循環シフト演算は以下のように見えます:

![CYP201](assets/fr/008.webp)

### 圧縮関数

基本的な操作を理解したところで、SHA256の圧縮関数を詳しく見ていきましょう。

前のステップで、入力を複数の512ビットのピース$P$に分割しました。各512ビットブロック$P$には:

- **メッセージワード $W_i$**: $i$は0から63まで。
- **定数 $K_i$**: $i$は0から63まで、前のステップで定義されました。
- **状態変数 $A, B, C, D, E, F, G, H$**: 前のステップからの値で初期化されます。
  最初の16語、$W_0$から$W_{15}$まで、は処理された512ビットブロック$P$から直接抽出されます。各語$W_i$は、ブロックから連続する32ビットで構成されます。例えば、最初の入力ピース$P_1$を取り、それをさらに小さな32ビットのピースに分割し、これを語と呼びます。

次の48語（$W_{16}$から$W_{63}$まで）は、以下の式を使用して生成されます：

$$
W_i = W_{i-16} + \sigma_0(W_{i-15}) + W_{i-7} + \sigma_1(W_{i-2}) \mod 2^{32}
$$

ここで：

- $\sigma_0(x) = RotR_7(x) \oplus RotR_{18}(x) \oplus ShR_3(x)$
- $\sigma_1(x) = RotR_{17}(x) \oplus RotR_{19}(x) \oplus ShR_{10}(x)$

この場合、$x$は$\sigma_0(x)$に対して$W_{i-15}$、$\sigma_1(x)$に対して$W_{i-2}$と等しくなります。

512ビットピースのすべての語$W_i$を決定したら、64ラウンドを実行する圧縮関数に移行します。

![CYP201](assets/fr/009.webp)
0から63までの各ラウンド$i$には、3種類の異なる入力があります。まず、メッセージピース$P_n$の一部である、ちょうど決定した$W_i$です。次に、64の定数$K_i$です。最後に、ハッシュ処理を通じて進化し、各圧縮関数で変更される状態変数$A$、$B$、$C$、$D$、$E$、$F$、$G$、および$H$を使用します。しかし、最初のピース$P_1$には、以前に与えられた初期定数を使用します。
次に、入力に対して以下の操作を実行します：

- **関数$\Sigma_0$：**

$$
\Sigma_0(A) = RotR_2(A) \oplus RotR_{13}(A) \oplus RotR_{22}(A)
$$

- **関数$\Sigma_1$：**

$$
\Sigma_1(E) = RotR_6(E) \oplus RotR_{11}(E) \oplus RotR_{25}(E)
$$

- **関数$Ch$（"_選択_")：**

$$
Ch(E, F, G) = (E \land F) \oplus (\lnot E \land G)
$$

- **関数$Maj$（"_多数決_")：**

$$
Maj(A, B, C) = (A \land B) \oplus (A \land C) \oplus (B \land C)
$$

次に、2つの一時変数を計算します：

- $temp1$：

$$
temp1 = H + \Sigma_1(E) + Ch(E, F, G) + K_i + W_i \mod 2^{32}
$$

- $temp2$：

$$
temp2 = \Sigma_0(A) + Maj(A, B, C) \mod 2^{32}
$$

次に、状態変数を次のように更新します：

$$
\begin{cases}
H = G \\
G = F \\
F = E \\
E = D + temp1 \mod 2^{32} \\
D = C \\
C = B \\
B = A \\
A = temp1 + temp2 \mod 2^{32}
\end{cases}
$$

以下は、SHA256圧縮関数のラウンドを表したものです：

![CYP201](assets/fr/010.webp)

- 矢印はデータの流れを示しています。
- ボックスは実行される操作を表しています。
- $+$で囲まれたものは、$2^{32}$を法とする加算を表しています。

このラウンドが新しい状態変数$A$、$B$、$C$、$D$、$E$、$F$、$G$、$H$を出力することがすでに観察できます。これらの新しい変数は次のラウンドの入力として機能し、次に新しい変数$A$、$B$、$C$、$D$、$E$、$F$、$G$、$H$を生成し、次のラウンドに使用されます。このプロセスは64ラウンドまで続きます。
64ラウンド後、最終ラウンドの終了時に最終値に初期値を加算することで、状態変数の初期値を更新します：

$$
\begin{cases}
A = A_{\text{initial}} + A \mod 2^{32} \\
B = B_{\text{initial}} + B \mod 2^{32} \\
C = C_{\text{initial}} + C \mod 2^{32} \\
D = D_{\text{initial}} + D \mod 2^{32} \\
E = E_{\text{initial}} + E \mod 2^{32} \\
F = F_{\text{initial}} + F \mod 2^{32} \\
G = G_{\text{initial}} + G \mod 2^{32} \\
H = H_{\text{initial}} + H \mod 2^{32}
\end{cases}

$$

これらの新しい値$A$、$B$、$C$、$D$、$E$、$F$、$G$、$H$は、次のブロック$P_2$の初期値として機能します。このブロック$P_2$では、同じ圧縮プロセスを64ラウンドで繰り返し、次にブロック$P_3$の変数を更新し、最後のブロックまでこのプロセスを続けます。

すべてのメッセージブロックを処理した後、変数$A$、$B$、$C$、$D$、$E$、$F$、$G$、$H$の最終値を連結して、ハッシュ関数の最終256ビットハッシュを形成します：


$$

\text{ハッシュ} = A \Vert B \Vert C \Vert D \Vert E \Vert F \Vert G \Vert H

$$

各変数は32ビット整数なので、その連結はメッセージ入力のサイズに関係なく常に256ビットの結果をもたらします。

### 暗号学的特性の正当化

では、この関数が不可逆で、衝突耐性があり、改ざん耐性がある理由は何でしょうか？

改ざん耐性については、理解しやすいです。入力と定数の両方に依存するカスケードで実行される計算が非常に多いため、初期メッセージのわずかな変更でも取られる経路が完全に変わり、結果として出力ハッシュが完全に変わります。これはアバランシュ効果と呼ばれるものです。この特性は、中間状態を各ピースの初期状態と混合することによって部分的に保証されます。
次に、暗号学的ハッシュ関数について議論する際、「可逆性」という用語は一般的に使用されません。代わりに、「事前画像耐性」という用語が使われ、任意の与えられた$y$に対して、$h(x) = y$となる$x$を見つけることが困難であることを指定します。この事前画像耐性は、圧縮関数で実行される操作の代数的複雑さと強い非線形性、およびプロセスでの特定情報の損失によって保証されます。例えば、加算モジュロの与えられた結果に対して、複数の可能なオペランドが存在します：
$$

3+2 \mod 10 = 5 \\
7+8 \mod 10 = 5 \\
5+10 \mod 10 = 5

$$

この例では、使用されるモジュロ（10）と結果（5）のみを知っている場合、加算で使用された正しいオペランドを確実に特定することはできません。モジュロ10に関して複数の合同式があると言われています。

XOR操作についても、同じ問題に直面しています。この操作の真理値表を思い出してください：1ビットの出力は、正しい値である可能性が全く同じである2つの異なる入力構成によって決定されます。したがって、その結果のみを知っている場合、XORのオペランドを確実に特定することはできません。XORオペランドのサイズを増やすと、結果のみを知っている場合の可能な入力の数は指数関数的に増加します。さらに、XORは$\text{RotR}$操作などの他のビットレベルの操作と一緒に使用されることが多く、結果にさらに多くの可能な解釈を加えます。

圧縮関数は$\text{ShR}$操作も使用します。この操作は基本情報の一部を取り除き、後で取り戻すことは不可能になります。再び、この操作を代数的に逆にする手段はありません。これらの一方向および情報損失操作は、圧縮関数で非常に頻繁に使用されます。与えられた出力に対する可能な入力の数はほぼ無限であり、逆計算の各試みは非常に多くの未知数を含む方程式につながり、各ステップで指数関数的に増加します。

最後に、衝突耐性の特性については、いくつかのパラメータが関係してきます。元のメッセージの前処理は重要な役割を果たします。この前処理がなければ、関数上で衝突を見つけることがより容易になるかもしれません。理論的には衝突が存在します（鳩の巣原理による）、ハッシュ関数の構造と前述の特性が組み合わさることで、衝突を見つける確率は極めて低くなります。
ハッシュ関数が衝突耐性であるためには、以下が不可欠です：
- 出力が予測不可能であること：任意の予測可能性は、ブルートフォース攻撃よりも速く衝突を見つけるために悪用される可能性があります。関数は、出力の各ビットが入力に非自明な方法で依存することを保証します。言い換えると、関数は最終結果の各ビットが0または1である独立した確率を持つように設計されていますが、この独立性は実際には絶対ではありません。
- ハッシュの分布が擬似ランダムであること：これにより、ハッシュが均一に分布されることが保証されます。
- ハッシュのサイズが大きいこと：結果の可能な空間が大きいほど、衝突を見つけることが難しくなります。

暗号学者はこれらの関数を設計する際に、衝突を見つけるための最良の可能な攻撃を評価し、その後これらの攻撃を無効にするためにパラメータを調整します。

### Merkle-Damgård構造

SHA256の構造はMerkle-Damgård構造に基づいており、これにより圧縮関数を任意の長さのメッセージを処理できるハッシュ関数に変換することができます。これはまさに私たちがこの章で見たことです。
しかし、SHA1やMD5のような古いハッシュ関数は、この特定の構造を使用していますが、長さ拡張攻撃に対して脆弱です。これは、攻撃者がメッセージ$M$のハッシュと$M$の長さ（メッセージ自体は知らない）を知っている場合に、$M$に追加の内容を連結したメッセージ$M'$のハッシュを計算できる技術です。
SHA256は、同じタイプの構造を使用しているにもかかわらず、SHA1やMD5とは異なり、理論的にはこのタイプの攻撃に対して耐性があります。これは、サトシ・ナカモトによってビットコイン全体で実装されたダブルハッシングの謎を説明するかもしれません。このタイプの攻撃を避けるために、サトシはダブルSHA256の使用を好んだかもしれません：


$$

\text{HASH256}(m) = \text{SHA256}(\text{SHA256}(m))

$$

これは、Merkle-Damgård構造に関連する潜在的な攻撃に対するセキュリティを強化しますが、衝突耐性の観点でハッシングプロセスのセキュリティを高めるわけではありません。さらに、SHA256がこのタイプの攻撃に対して脆弱であったとしても、ビットコインでのハッシュ関数の使用例はすべて公開データに関連しているため、深刻な影響はありませんでした。しかし、ハッシュ化されたデータがプライベートであり、ユーザーがこれらのデータの認証メカニズムとしてハッシュ関数を使用している場合、長さ拡張攻撃は攻撃者にとってのみ有用かもしれません。したがって、ビットコインの設計におけるダブルハッシングの実装は依然として謎です。
ハッシュ関数、特にビットコインで広く使用されているSHA256の仕組みを詳しく見てきましたが、次に、特にウォレットの鍵を導出するためにアプリケーションレベルで使用される暗号化導出アルゴリズムに特に焦点を当てます。

## 導出に使用されるアルゴリズム
<chapterId>cc668121-7789-5e99-bf5e-1ba085f4f5f2</chapterId>

ビットコインではアプリケーションレベルで、ハッシュ関数に加えて、初期入力から安全なデータを生成するための暗号化導出アルゴリズムが使用されます。これらのアルゴリズムはハッシュ関数に依存していますが、特に認証と鍵生成の観点で異なる目的を果たします。これらのアルゴリズムは、不可逆性、改ざん耐性、衝突耐性など、ハッシュ関数のいくつかの特性を保持しています。

ビットコインウォレットでは、主に2つの導出アルゴリズムが使用されます：
1. **HMAC (*Hash-based Message Authentication Code*)**
2. **PBKDF2 (*Password-Based Key Derivation Function 2*)**

それぞれの機能と役割について一緒に探っていきましょう。

### HMAC-SHA512

HMACは、ハッシュ関数と秘密鍵の組み合わせに基づいて認証コードを計算する暗号化アルゴリズムです。ビットコインでは、SHA512ハッシュ関数を使用するHMACのバリアントであるHMAC-SHA512が使用されます。前章で既に見たように、SHA512はSHA256と同じハッシュ関数のファミリーに属していますが、512ビットの出力を生成します。

ここでは、$m$が入力メッセージであり、$K$が秘密鍵である一般的な動作スキームを示します：

![CYP201](assets/fr/011.webp)

このHMAC-SHA512ブラックボックスで何が起こっているのか、もっと詳しく見ていきましょう。HMAC-SHA512関数では：
- $m$：ユーザーが選択した任意のサイズのメッセージ（最初の入力）；
- $K$：ユーザーが選択した任意の秘密鍵（2番目の入力）；
- $K'$：ハッシュ関数ブロックのサイズ$B$（SHA512の場合は1024ビット、または128バイト）に調整された鍵$K$；
- $\text{SHA512}$：SHA512ハッシュ関数；
- $\oplus$：XOR（排他的論理和）操作；
- $\Vert$: ビット文字列を端から端まで連結するための演算子です。
- $\text{opad}$: バイト $0x5c$ を128回繰り返した定数です。
- $\text{ipad}$: バイト $0x36$ を128回繰り返した定数です。

HMACを計算する前に、鍵と定数をブロックサイズ $B$ に合わせて均一化する必要があります。例えば、鍵 $K$ が128バイトより短い場合、サイズ $B$ に達するまでゼロでパディングされます。$K$ が128バイトより長い場合、SHA512を使用して圧縮され、128バイトに達するまでゼロが追加されます。この方法で、均一化された鍵 $K'$ が得られます。
$\text{opad}$ と $\text{ipad}$ の値は、基本バイト（$\text{opad}$ の場合は $0x5c$、$\text{ipad}$ の場合は $0x36$）をサイズ $B$ に達するまで繰り返すことで得られます。したがって、$B = 128$ バイトの場合、次のようになります：


$$

\text{opad} = \underbrace{0x5c5c\ldots5c}\_{128 \, \text{バイト}}

$$

前処理が完了すると、HMAC-SHA512アルゴリズムは以下の方程式で定義されます：


$$

\text {HMAC-SHA512}\_K(m) = \text{SHA512} \left( (K' \oplus \text{opad}) \parallel \text{SHA512} \left( (K' \oplus \text{ipad}) \parallel m \right) \right)

$$

この方程式は以下のステップに分解されます：
1. 調整された鍵 $K'$ と $\text{ipad}$ をXORして $\text{iKpad}$ を得る；
2. 調整された鍵 $K'$ と $\text{opad}$ をXORして $\text{oKpad}$ を得る；
3. $\text{iKpad}$ とメッセージ $m$ を連結する。
4. この結果をSHA512でハッシュして中間ハッシュ $H_1$ を得る。
5. $\text{oKpad}$ と $H_1$ を連結する。
6. この結果をSHA512でハッシュして最終結果 $H_2$ を得る。

これらのステップは以下のように図式化できます：

![CYP201](assets/fr/012.webp)

HMACは、特にHD（階層的決定性）ウォレットの鍵導出において、またPBKDF2のコンポーネントとして、ビットコインで使用されます。

### PBKDF2

PBKDF2（*Password-Based Key Derivation Function 2*）は、パスワードのセキュリティを強化するために設計された鍵導出アルゴリズムです。このアルゴリズムは、パスワードと暗号学的ソルトに対して擬似ランダム関数（ここではHMAC-SHA512）を適用し、その操作を特定の回数繰り返して出力鍵を生成します。

ビットコインでは、PBKDF2はニーモニックフレーズとパスフレーズからHDウォレットのシードを生成するために使用されます（これについては後の章で詳しく説明します）。

PBKDF2プロセスは以下の通りです：
- $m$: ユーザーのニーモニックフレーズ；
- $s$: セキュリティを高めるためのオプションのパスフレーズ（パスフレーズがない場合は空欄）；
- $n$: 関数の繰り返し回数、この場合は2048回です。
PBKDF2関数は反復的に定義されています。各反復は前の結果を取り、それをHMAC-SHA512を通して処理し、連続する結果を組み合わせて最終的なキーを生成します：
$$

\text{PBKDF2}(m, s) = \text{HMAC-SHA512}^{2048}(m, s)

$$

概略的に、PBKDF2は以下のように表されます：

![CYP201](assets/fr/013.webp)

この章では、ビットコインプロトコルにおけるキー導出の完全性とセキュリティを保証するためにハッシュ関数を使用するHMAC-SHA512およびPBKDF2関数について探求しました。次の部分では、ビットコインで広く使用されている別の暗号化方法であるデジタル署名について見ていきます。

# デジタル署名
<partId>76b58a00-0c18-54b9-870d-6b7e34029db8</partId>

## デジタル署名と楕円曲線
<chapterId>c9dd9672-6da1-57f8-9871-8b28994d4c1a</chapterId>

ビットコインで使用される2番目の暗号化方法は、デジタル署名アルゴリズムを含みます。これが何を意味し、どのように機能するかを探りましょう。

### ビットコイン、UTXO、および支出条件

ビットコインにおける「*ウォレット*」という用語は初心者にとってかなり混乱することがあります。実際、ビットコインウォレットと呼ばれるものは、コインや紙幣を保持できる物理的なウォレットとは異なり、直接的にあなたのビットコインを保持するソフトウェアです。ビットコインは単に勘定単位です。この勘定単位は、**UTXO** (*Unspent Transaction Outputs*、未使用のトランザクション出力)によって表されます。これらの出力が未使用である場合、それはユーザーに属していることを意味します。UTXOは、ある意味で、ユーザーに属する可変サイズのビットコインの断片です。

ビットコインプロトコルは分散されており、中央機関なしで運用されます。したがって、あなたに属するユーロが個人の身元に単純に関連付けられている従来の銀行記録のようではありません。ビットコイン上では、UTXOがScript言語で指定された支出条件によって保護されているため、それらはあなたに属しています。簡単に言うと、2種類のスクリプトがあります：UTXOを保護するロックスクリプト（*scriptPubKey*）と、UTXOをアンロックしてそれが表すビットコイン単位を支出することを可能にするアンロックスクリプト（*scriptSig*）です。
ビットコインの初期運用では、公開鍵を使用して資金をロックし、このUTXOを支出するためには、この公開鍵に対応する秘密鍵で有効な署名を提供する必要があることを*scriptPubKey*で指定していました。このUTXOをアンロックするには、したがって*scriptSig*で有効な署名を提供する必要があります。その名前が示すように、公開鍵はブロックチェーン上で公開されているため誰もが知っていますが、秘密鍵は資金の正当な所有者のみが知っています。
これはビットコインの基本的な運用ですが、時間が経つにつれて、この運用はより複雑になりました。最初に、サトシは受信アドレスを*scriptPubKey*に使用するP2PKHスクリプトも導入しました。これは公開鍵のハッシュを表します。その後、SegWitやTaprootの登場により、システムはさらに複雑になりました。しかし、一般的な原則は基本的に同じままです：公開鍵またはこの鍵の表現がUTXOをロックするために使用され、それらをアンロックして支出するためには対応する秘密鍵が必要です。
ビットコイン取引を行いたいユーザーは、問題の取引に対して自分の秘密鍵を使用してデジタル署名を作成する必要があります。この署名は、他のネットワーク参加者によって検証することができます。もし有効であれば、取引を開始するユーザーが実際に秘密鍵の所有者であり、したがって彼らが使いたいビットコインの所有者であることを意味します。他のユーザーはその後、取引を受け入れて伝播することができます。
その結果、公開鍵でロックされたビットコインを所有するユーザーは、資金のロックを解除するために必要なもの、つまり秘密鍵を安全に保管する方法を見つける必要があります。ビットコインウォレットは、他の人がアクセスできないようにすべての鍵を簡単に保管できるデバイスです。したがって、財布というよりは鍵束のようなものです。

公開鍵と秘密鍵の間の数学的なリンク、および秘密鍵を明らかにすることなくその所有を証明する署名を実行する能力は、デジタル署名アルゴリズムによって可能にされます。ビットコインプロトコルでは、2つの署名アルゴリズムが使用されています：**ECDSA**（*楕円曲線デジタル署名アルゴリズム*）と**Schnorr署名スキーム**です。ECDSAはビットコインの始まりから使用されているデジタル署名プロトコルです。Schnorrはビットコインにおいてより最近のもので、2021年11月のTaprootアップデートで導入されました。
これら2つのアルゴリズムは、そのメカニズムにおいてかなり似ています。両方とも楕円曲線暗号に基づいています。これら2つのプロトコルの主な違いは、署名の構造といくつかの特定の数学的特性にあります。したがって、最も古いものから始めて、これらのアルゴリズムの機能を研究します：ECDSA。
### 楕円曲線暗号

楕円曲線暗号（ECC）は、暗号目的のためにその様々な数学的および幾何学的特性を利用する楕円曲線を使用する一連のアルゴリズムです。これらのアルゴリズムのセキュリティは、楕円曲線上の離散対数問題の難しさに依存しています。楕円曲線は、鍵交換、非対称暗号化、またはデジタル署名の作成に特に使用されます。

これらの曲線の重要な特性の一つは、x軸に関して対称であることです。したがって、曲線を2つの異なる点で切る任意の非垂直線は、常に第三の点で曲線と交差します。さらに、非特異点での曲線の接線は、別の点で曲線と交差します。これらの特性は、曲線上での操作を定義するために役立ちます。

こちらは実数の範囲での楕円曲線の表現です：

![CYP201](assets/fr/014.webp)

すべての楕円曲線は、以下の形式の方程式で定義されます：


$$

y^2 = x^3 + ax + b

$$

### secp256k1

ECDSAまたはSchnorrを使用するには、楕円曲線のパラメータ、つまり曲線方程式の$a$と$b$の値を選択する必要があります。暗号学的に安全とされる楕円曲線の異なる標準があります。最もよく知られているのは、NIST（*国立標準技術研究所*）によって定義され推奨される*secp256r1*曲線です。

それにもかかわらず、ビットコインの発明者であるサトシ・ナカモトは、この曲線を使用しないことを選択しました。この選択の理由は不明ですが、この曲線のパラメータにバックドアが含まれている可能性があるため、代替を見つけることを好んだと考える人もいます。代わりに、ビットコインプロトコルは***secp256k1***標準曲線を使用しています。この曲線は、$a = 0$および$b = 7$のパラメータで定義されています。その方程式はしたがって：


$$

y^2 = x^3 + 7

$$

そのグラフィカルな表現は実数の範囲で次のようになります：

![CYP201](assets/fr/015.webp)

暗号学では、有限の数の集合を扱います。具体的には、素数 $p$ を法とする整数の有限体 $\mathbb{F}_p$ 上で作業します。
**定義**: 素数とは、2以上の自然数で、正の整数の約数が1とその数自身のみであるものを指します。例えば、数7は1と7でしか割ることができないので素数です。一方、数8は1, 2, 4, 8で割ることができるので素数ではありません。
ビットコインでは、有限体を定義するために使用される素数 $p$ は非常に大きいです。この有限体の位数（つまり、$\mathbb{F}_p$ の要素の数）が暗号学的な安全性を確保するのに十分に大きくなるように選ばれています。

使用される素数 $p$ は以下の通りです：

```text
p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
```

10進数表記では、これは以下に相当します：


$$

p = 2^{256} - 2^{32} - 977

$$

したがって、私たちの楕円曲線の方程式は実際には以下のようになります：


$$

y^2 \equiv x^3 + 7 \mod p

$$

この曲線が有限体 $\mathbb{F}_p$ 上で定義されているため、連続した曲線ではなく、離散的な点の集合として現れます。例えば、こちらが非常に小さい $p = 17$ の場合のビットコインで使用される曲線の様子です：

![CYP201](assets/fr/016.webp)

この例では、教育的な理由から有限体を $p = 17$ に限定していますが、ビットコインで使用されるものはほぼ $2^{256}$ という途方もなく大きなものであると想像する必要があります。

曲線上の演算の正確性を保証するために、$p$ を法とする整数の有限体を使用します。実数の体上の楕円曲線は、計算過程での丸め誤差により不正確さが生じる可能性があります。曲線上で多数の演算が行われると、これらの誤差が蓄積し、最終結果が不正確になったり、再現が困難になることがあります。正の整数のみを使用することで、計算の完全な正確性と結果の再現性を保証します。

有限体上の楕円曲線の数学は、実数の体上のそれと類似していますが、すべての演算が $p$ を法として行われる点が適応されています。説明を簡単にするために、実数上で定義された曲線を使用して概念を説明し続けますが、実際には曲線が有限体上で定義されていることを念頭に置いてください。

現代暗号学の数学的基礎についてさらに学びたい場合は、Plan ₿ Network上のこの他のコースもお勧めします：

https://planb.network/courses/cyp302

## 私鍵から公開鍵を計算する
<chapterId>fcb2bd58-5dda-5ecf-bb8f-ad1a0561ab4a</chapterId>
以前見たように、ビットコインのデジタル署名アルゴリズムは、数学的にリンクされた一対の秘密鍵と公開鍵に基づいています。この数学的なリンクが何であるか、そしてそれらがどのように生成されるかを一緒に探りましょう。

### 私鍵

私鍵は単にランダムまたは擬似ランダム数です。ビットコインの場合、この数は256ビットのサイズです。したがって、ビットコインの私鍵の理論上の可能性の数は $2^{256}$ です。
**注記**: 「擬似乱数」とは、真にランダムな数に近い性質を持つが、決定論的なアルゴリズムによって生成される数のことです。
しかし、実際には、楕円曲線secp256k1上には$n$個の異なる点のみが存在し、ここで$n$は曲線の生成点$G$の位数です。この数が何に対応するかは後ほど見ますが、単に有効な秘密鍵は$1$から$n-1$の間の整数であることを覚えておいてください。ここで$n$は$2^{256}$に非常に近いがそれよりわずかに小さい数です。したがって、Bitcoinの秘密鍵になり得ない256ビットの数が存在します。具体的には、$n$と$2^{256}$の間のすべての数です。乱数（秘密鍵）の生成が$k \geq n$となる値$k$を生み出した場合、それは無効と見なされ、新たな乱数値を生成する必要があります。

したがって、Bitcoinの秘密鍵の可能性の数は約$n$であり、これは$1.158 \times 10^{77}$に非常に近い数です。この数は非常に大きいため、ランダムに秘密鍵を選んだ場合、他のユーザーの秘密鍵に偶然当たることは統計的にほぼ不可能です。規模のイメージを持ってもらうために、Bitcoinの可能な秘密鍵の数は、観測可能な宇宙の推定原子数に近いオーダーの大きさです。

これからの章で見ていくように、今日、Bitcoinで使用されている秘密鍵の大多数はランダムに生成されたものではなく、擬似乱数であるニーモニックフレーズから決定論的に導出された結果です（これが有名な12または24の言葉のフレーズです）。この情報は、ECDSAのような署名アルゴリズムの使用には何も変わりませんが、Bitcoinに関する私たちの普及活動を再集中させるのに役立ちます。

説明の続きでは、秘密鍵は小文字の$k$で表されます。

### 公開鍵
公開鍵は楕円曲線上の点であり、大文字の$K$で表され、秘密鍵$k$から計算されます。この点$K$は、楕円曲線上の座標$(x, y)$のペアで表され、各座標は有限体$\mathbb{F}_p$を定義する素数$p$に対する整数のモジュロです。
実際には、非圧縮公開鍵は512ビット（または64バイト）で表され、これは2つの256ビット数（$x$と$y$）を端から端まで配置したものに相当します。これらの数は、secp256k1上の私たちの点の$x$座標（横軸）と$y$座標（縦軸）です。接頭辞を加えると、公開鍵は合計で520ビットになります。

しかし、曲線上の点の$x$座標のみを保持し、$y$の偶奇を示すバイトを使用して、公開鍵を33バイト（264ビット）のみで表す圧縮形式も可能です。これが圧縮公開鍵として知られています。このトレーニングの最後の章でこれについてもっと話します。しかし、覚えておくべきことは、公開鍵$K$は$x$と$y$によって記述される点であるということです。

公開鍵に対応する点$K$を計算するために、楕円曲線上でのスカラー乗算の操作を使用します。これは、生成点$G$の繰り返し加算（$k$回）として定義されます：


$$

K = k \cdot G

$$

ここで：
- $k$は秘密鍵です（$1$から$n-1$の間のランダムな整数）。
- $G$は、Bitcoinネットワークの全参加者が使用する楕円曲線の生成点です。
- $\cdot$は楕円曲線上のスカラー乗算を表し、これは点$G$を自身に$k$回加えることと同等です。

この点$G$がBitcoin上の全公開鍵に共通であるという事実は、同じ秘密鍵$k$が常に同じ公開鍵$K$を生成することを確信させます：

![CYP201](assets/fr/017.webp)

この操作の主な特徴は、一方向関数であることです。秘密鍵$k$と生成点$G$を知っていれば公開鍵$K$を簡単に計算できますが、公開鍵$K$と生成点$G$のみを知っている状態で秘密鍵$k$を計算することは実質的に不可能です。$K$と$G$から$k$を見つけることは、楕円曲線上の離散対数問題を解決することに相当し、これは効率的なアルゴリズムが知られていない数学的に難しい問題です。現在の最も強力な計算機でも、この問題を合理的な時間内に解決することはできません。

![CYP201](assets/fr/018.webp)

### 楕円曲線上の点の加算と倍加

楕円曲線上の加算の概念は幾何学的に定義されます。曲線上の二つの点$P$と$Q$がある場合、操作$P + Q$は$P$と$Q$を通る直線を引くことによって計算されます。この直線は必ず曲線と第三の点$R'$で交差します。次に、この点のx軸に関する鏡像を取って、加算の結果である点$R$を得ます：


$$

P + Q = R

$$

グラフィカルには、以下のように表されます：

![CYP201](assets/fr/019.webp)

点の倍加、つまり操作$P + P$については、点$P$で曲線に接する接線を引きます。この接線は曲線と別の点$S'$で交差します。次に、この点のx軸に関する鏡像を取って、倍加の結果である点$S$を得ます：


$$

2P = S

$$

グラフィカルには、以下のように示されます：

![CYP201](assets/fr/020.webp)

これらの加算と倍加の操作を使用して、整数$k$による点のスカラー乗算$kP$を、繰り返しの倍加と加算を行うことによって実行できます。

例えば、秘密鍵$k = 4$を選択したとします。関連する公開鍵を計算するには：


$$

K = k \cdot G = 4G

$$

グラフィカルには、一連の加算と倍加を行うことに相当します：
- $G$を倍加して$2G$を計算します。
- $2G$を倍加して$4G$を計算します。

![CYP201](assets/fr/021.webp)

例えば、点$3G$を計算したい場合は、まず点$G$を倍加して点$2G$を計算し、次に$G$と$2G$を加算します。$G$と$2G$を結ぶ直線を引き、この直線と楕円曲線の交点である一意の点$-3G$を取得し、次に$-3G$の反対である$3G$を決定します。

すると、以下のようになります：


$$

G + G = 2G

$$


$$

2G + G = 3G

$$

グラフィカルには、以下のように表されます：

![CYP201](assets/fr/022.webp)

### 片方向関数

これらの操作のおかげで、プライベートキーから公開キーを導出することは容易であるが、その逆が事実上不可能である理由を理解することができます。

私たちの簡略化された例に戻りましょう。プライベートキー $k = 4$ で、関連する公開キーを計算するために、次の操作を行います：

$$
K = k \cdot G = 4G
$$

こうして、$k$ と $G$ を知ることによって、容易に公開キー $K$ を計算することができました。

しかし、誰かが公開キー $K$ のみを知っている場合、彼らは離散対数問題に直面します：$K = k \cdot G$ となる $k$ を見つけること。この問題は、楕円曲線上でそれを解く効率的なアルゴリズムが存在しないため、難しいと考えられています。これにより、ECDSAおよびSchnorrアルゴリズムのセキュリティが保証されます。

もちろん、$k = 4$ というこの簡略化された例では、可能性の数が少ないため、試行錯誤によって $k$ を見つけることが可能です。しかし、実際にはBitcoin上で $k$ は256ビット整数であり、可能性の数が天文学的に大きい（約 $1.158 \times 10^{77}$）ため、ブルートフォースによって $k$ を見つけることは不可能です。

## プライベートキーでの署名

<chapterId>bb07826f-826e-5905-b307-3d82001fb778</chapterId>

プライベートキーから公開キーを導出する方法を知った今、このキーペアを使用して支出条件としてビットコインを受け取ることができます。しかし、どのようにしてそれらを使うのでしょうか？ビットコインを使うためには、あなたがその正当な所有者であることを証明するために、あなたのUTXOに添付された _scriptPubKey_ を解除する必要があります。これを行うには、$K$ に対応する公開キーと初めに $K$ を計算するために使用されたプライベートキー $k$ を使用して署名 $s$ を生成する必要があります。デジタル署名は、あなたが主張する公開キーに関連付けられたプライベートキーを所有していることの明確な証拠です。

### 楕円曲線パラメータ

デジタル署名を実行するために、すべての参加者は最初に使用される楕円曲線のパラメータに同意する必要があります。Bitcoinの場合、**secp256k1** のパラメータは以下の通りです：

有限体 $\mathbb{Z}_p$ は次によって定義されます：

$$
p = 2^{256} - 2^{32} - 977
$$

```text
p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
```

$p$ は $2^{256}$ よりわずかに小さい非常に大きな素数です。

有限体 $\mathbb{Z}_p$ 上の楕円曲線 $y^2 = x^3 + ax + b$ は次によって定義されます：

$$
a = 0, \quad b = 7
$$

生成点または原点 $G$：

```text
G = 0x0279BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798
```

この数値は、点 $G$ の横座標のみを与える圧縮形式です。冒頭の `02` は、この横座標 $x$ を持つ2つの値のうちどちらを生成点として使用するかを決定します。
$G$ の位数 $n$（存在する点の数）と余因子 $h$：

```text
n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141
```

$n$は非常に大きな数で、$p$よりわずかに小さいです。

$$
h=1
$$

$h$は補助因子、または部分群の数です。これが何を表しているかについてはここでは詳しく述べません。なぜなら、それはかなり複雑であり、ビットコインの場合、それが$1$に等しいため、考慮する必要がないからです。

これらの情報は公開されており、すべての参加者が知っています。これにより、ユーザーはデジタル署名を行い、それを検証することができます。

### ECDSAを用いた署名

ECDSAアルゴリズムを使用すると、ユーザーは自分の秘密鍵を使用してメッセージに署名でき、対応する公開鍵を知っている人なら誰でも、秘密鍵が明らかにされることなく署名の有効性を検証できます。ビットコインの文脈では、署名されるべきメッセージはユーザーが選択した*sighash*に依存します。この*sighash*がトランザクションのどの部分が署名によってカバーされるかを決定します。これについては次の章で詳しく説明します。

ECDSA署名を生成する手順は以下の通りです：

まず、署名されるべきメッセージのハッシュ($e$)を計算します。メッセージ$m$は、一般的にはSHA256またはビットコインの場合はダブルSHA256などの暗号化ハッシュ関数を通して処理されます：

$$
e = \text{HASH}(m)
$$

次に、ノンスを計算します。暗号学において、ノンスは単に一度だけ使用されるランダムまたは擬似ランダムに生成された数です。つまり、この鍵のペアで新しいデジタル署名が行われるたびに、異なるノンスを使用することが非常に重要であり、そうでなければ秘密鍵のセキュリティが損なわれます。したがって、楕円曲線の生成点$G$の位数$n$に対して$1 \leq r \leq n-1$となるランダムで一意の整数$r$を決定することが十分です。

次に、楕円曲線上の点$R$を座標$(x_R, y_R)$で計算します。そのようにして：

$$
R = r \cdot G
$$

点$R$の横座標の値($x_R$)を抽出します。この値は署名の第一部分を表します。そして最後に、この方法で署名の第二部分$s$を計算します：

$$
s = r^{-1} \left( e + k \cdot x_R \right) \mod n
$$

ここで：

- $r^{-1}$は$r$の$n$に対するモジュラ逆数であり、つまり$r \cdot r^{-1} \equiv 1 \mod n$となる整数です；
- $k$はユーザーの秘密鍵です；
- $e$はメッセージのハッシュです；
- $n$は楕円曲線の生成点$G$の位数です。

署名は単純に$x_R$と$s$の連結です：

$$
\text{SIG} = x_R \Vert s
$$

### ECDSA署名の検証

署名$(x_R, s)$を検証するには、公開鍵$K$と楕円曲線のパラメータを知っている人なら誰でも、この方法で進めることができます：
まず、$x_R$ と $s$ が区間 $[1, n-1]$ 内にあることを確認します。これにより、署名が楕円群の数学的制約を尊重していることが保証されます。そうでない場合、検証者は直ちに署名を無効として拒否します。
次に、メッセージのハッシュを計算します：

$$
e = \text{HASH}(m)
$$

$n$ を法とする $s$ の逆数を計算します：

$$
s^{-1} \mod n
$$

この方法で二つのスカラー値 $u_1$ と $u_2$ を計算します：

$$
\begin{align*}
u_1 &= e \cdot s^{-1} \mod n \\
u_2 &= x_R \cdot s^{-1} \mod n
\end{align*}
$$

そして最後に、楕円曲線上の点 $V$ を次のように計算します：

$$
V = u_1 \cdot G + u_2 \cdot K
$$

署名が有効であるのは、$x_V \equiv x_R \mod n$ の場合のみです。ここで $x_V$ は点 $V$ の $x$ 座標です。実際には、$u_1 \cdot G$ と $u_2 \cdot K$ を組み合わせることで、署名が有効であれば、署名時に使用された点 $R$（$n$ を法として）に対応するべき点 $V$ が得られます。

### Schnorr プロトコルによる署名

Schnorr 署名スキームは、多くの利点を提供する ECDSA への代替手段です。2021年の Taproot の導入と P2TR スクリプトパターンにより、Bitcoin での使用が可能になりました。ECDSA と同様に、Schnorr スキームでは、対応する公開鍵を知っている人なら誰でも検証できるように、秘密鍵を使用してメッセージに署名します。
Schnorr の場合、ECDSA と全く同じ曲線が同じパラメーターで使用されます。しかし、公開鍵は ECDSA と比較してわずかに異なる方法で表されます。実際、それらは楕円曲線上の点の $x$ 座標のみによって指定されます。ECDSA では、圧縮公開鍵が 33 バイト（$y$ の偶奇を示すプレフィックスバイト付き）で表されるのに対し、Schnorr では点 $K$ の $x$ 座標にのみ対応する 32 バイトの公開鍵を使用し、$y$ はデフォルトで偶数であると仮定されます。この簡略化された表現は、署名のサイズを減らし、検証アルゴリズムの特定の最適化を容易にします。
公開鍵は点 $K$ の $x$ 座標です：

$$
\text{pk} = K_x
$$

署名を生成する最初のステップは、メッセージをハッシュ化することです。しかし、ECDSA とは異なり、他の値と一緒にラベル付きハッシュ関数が使用され、異なるコンテキストでの衝突を避けます。ラベル付きハッシュ関数は、単にメッセージデータとともにハッシュ関数の入力に任意のラベルを追加することを意味します。

![CYP201](assets/fr/023.webp)

メッセージに加えて、公開鍵 $K_x$ の $x$ 座標、およびノンス $r$（$R=r \cdot G$）から計算された点 $R$ もラベル付き関数に渡されます。ノンスは、秘密鍵とメッセージから決定論的に計算される各署名ごとに一意の整数であり、ノンスの再利用に関連する脆弱性を避けます。公開鍵と同様に、ノンス点 $R_x$ の $x$ 座標のみが点を記述するために保持されます。

このハッシュの結果は「チャレンジ」と呼ばれ、次のように記されます：

$$
e = \text{HASH}(\text{``BIP0340/challenge''}, R_x \Vert K_x \Vert m) \mod n
$$

ここで、$\text{HASH}$はSHA256ハッシュ関数であり、\text{``BIP0340/challenge''}はハッシングのための特定のタグです。

最終的に、パラメータ$s$は、秘密鍵$k$、nonce$r$、そしてチャレンジ$e$からこの方法で計算されます：

$$
s = (r + e \cdot k) \mod n
$$

署名は単純にペア$Rx$と$s$です。

$$
\text{SIG} = R_x \Vert s
$$

### Schnorr署名の検証

Schnorr署名の検証は、ECDSA署名の検証よりも簡単です。公開鍵$K_x$とメッセージ$m$を使って署名$(R_x, s)$を検証する手順は以下の通りです：
まず、$K_x$が有効な整数であり$p$より小さいことを確認します。この場合、$K_y$が偶数である曲線上の対応する点を取得します。また、署名$\text{SIG}$を分離することで$R_x$と$s$を抽出します。次に、$R_x < p$および$s < n$（曲線の位数）であることを確認します。
次に、署名の発行者と同じ方法でチャレンジ$e$を計算します：

$$
e = \text{HASH}(\text{``BIP0340/challenge''}, R_x \Vert K_x \Vert m) \mod n
$$

その後、この方法で曲線上の参照点を計算します：

$$
R' = s \cdot G - e \cdot K
$$

最後に、$R'_x = R_x$であることを確認します。2つのx座標が一致すれば、署名$(R_x, s)$は公開鍵$K_x$で有効であると確認されます。

### これが機能する理由

署名者は$s = r + e \cdot k \mod n$を計算しているので、$R' = s \cdot G - e \cdot K$は元の点$R$と等しくなければなりません。なぜなら：

$$
s \cdot G = (r + e \cdot k) \cdot G = r \cdot G + e \cdot k \cdot G
$$

$K = k \cdot G$であるため、$e \cdot k \cdot G = e \cdot K$となります。したがって：

$$
R' = r \cdot G = R
$$

その結果、以下が成り立ちます：

$$
R'_x = R_x
$$

### Schnorr署名の利点

Schnorr署名方式は、元のECDSAアルゴリズムに比べてBitcoinにいくつかの利点を提供します。まず、Schnorrは鍵と署名の集約を可能にします。これは、複数の公開鍵を単一の鍵に組み合わせることができることを意味します。

![CYP201](assets/fr/024.webp)

同様に、複数の署名を単一の有効な署名に集約することができます。したがって、マルチシグネチャトランザクションの場合、参加者のセットは単一の署名と単一の集約された公開鍵で署名することができます。これは、各ノードが単一の署名のみを検証する必要があるため、ネットワークのストレージと計算コストを大幅に削減します。

![CYP201](assets/fr/025.webp)

さらに、署名の集約はプライバシーを向上させます。Schnorrを使用すると、マルチシグネチャトランザクションを標準の単一署名トランザクションと区別することが不可能になります。この均一性はチェーン分析をより困難にし、ウォレットのフィンガープリントを特定する能力を制限します。
最後に、Schnorr署名はバッチ検証の可能性も提供します。複数の署名を同時に検証することで、特に多くのトランザクションを含むブロックの場合、ノードは効率を向上させることができます。この最適化により、ブロックを検証するために必要な時間とリソースが削減されます。また、Schnorr署名は、ECDSAで生成された署名とは異なり、変形可能ではありません。これは、攻撃者が有効な署名を変更して、同じメッセージと同じ公開鍵に対する別の有効な署名を作成することができないことを意味します。この脆弱性は以前、Bitcoinに存在し、特にLightning Networkの安全な実装を妨げていました。これは2017年のSegWitソフトフォークでECDSAに対して解決されました。これにより、署名をトランザクションから別のデータベースに移動して、その変形可能性を防ぎます。

### なぜサトシはECDSAを選んだのか？

見てきたように、サトシは当初、Bitcoinのデジタル署名にECDSAを実装することを選びました。しかし、Schnorrが多くの面でECDSAよりも優れていることも見てきましたし、このプロトコルは1989年にClaus-Peter Schnorrによって作成され、Bitcoinの発明の20年前です。

実際のところ、サトシがなぜそれを選ばなかったのかはわかりませんが、このプロトコルが2008年まで特許下にあったという仮説があります。Bitcoinが作成されたのはその1年後の2009年1月ですが、その時点でSchnorr署名のオープンソース標準化は利用可能ではありませんでした。おそらくサトシは、既に広く使用されテストされていたECDSAを使用する方が安全だと考えたのでしょう。または、この特許が2008年に失効することを知らなかったのかもしれません。いずれにせよ、最も可能性が高い仮説はこの特許と、ECDSAが実績があり実装が容易だったという事実に関連しているようです。

## sighashフラグ

<chapterId>231c41a2-aff2-4655-9048-47b6d2d83d64</chapterId>

前の章で見てきたように、デジタル署名はしばしば入力のスクリプトを解除するために使用されます。署名プロセスでは、計算に署名されたデータを含める必要があります。これは、私たちの例ではメッセージ$m$と指定されています。一度署名されたこのデータは、署名を無効にすることなく変更することはできません。実際、ECDSAでもSchnorrでも、署名検証者は計算に同じメッセージ$m$を含める必要があります。それが署名者が最初に使用したメッセージ$m$と異なる場合、結果は正しくなく、署名は無効とみなされます。そのため、署名は特定のデータをカバーし、ある意味で、無許可の変更から保護すると言われます。

### sighashフラグとは何か？

Bitcoinの特定のケースでは、メッセージ$m$がトランザクションに対応していることを見てきました。しかし、実際にはもう少し複雑です。実際、sighashフラグのおかげで、署名によってカバーされるかどうかを選択するトランザクション内の特定のデータを選択することが可能です。
「sighashフラグ」は、トランザクションの各入力に追加されるパラメータであり、関連する署名によってカバーされるトランザクションのコンポーネントを決定します。これらのコンポーネントは入力と出力です。sighashフラグの選択によって、署名によって固定されるトランザクションの入力と出力、およびそれを無効にすることなく変更できるものが決定されます。このメカニズムにより、署名は署名者の意図に従ってトランザクションデータをコミットすることができます。
トランザクションがブロックチェーン上で確認されると、使用されたsighashフラグに関係なく、それは不変となります。sighashフラグを介した変更の可能性は、署名と確認の間の期間に限定されます。
一般的に、ウォレットソフトウェアはトランザクションを構築する際に、入力のsighashフラグを手動で変更するオプションを提供しません。デフォルトでは、`SIGHASH_ALL`が設定されています。個人的には、Sparrow Walletがユーザーインターフェースからこの変更を許可する唯一のウォレットを知っています。

### Bitcoinに存在するsighashフラグとは何ですか？

Bitcoinには、まず第一に3つの基本的なsighashフラグがあります：

- `SIGHASH_ALL` (`0x01`): 署名はトランザクションのすべての入力とすべての出力に適用されます。したがって、トランザクションは署名によって完全にカバーされ、もはや変更することはできません。`SIGHASH_ALL`は、変更されることなくトランザクションを行いたい場合に、日常的な取引で最も一般的に使用されるsighashです。

![CYP201](assets/fr/026.webp)

この章のすべての図では、オレンジ色は署名によってカバーされた要素を表し、黒色はそれ以外の要素を示しています。

- `SIGHASH_NONE` (`0x02`): 署名はすべての入力をカバーしますが、出力は一切カバーしません。これにより、署名後に出力を変更することが可能になります。具体的には、これは白紙委任状に似ています。署名者は入力のUTXOsをアンロックしますが、出力のフィールドを完全に変更可能に残します。このトランザクションを知る人は誰でも、例えば入力によって消費された資金を集めるための受取アドレスを指定して出力を追加し、その後トランザクションをブロードキャストしてビットコインを回収することができます。入力のみをカバーするため、入力の所有者の署名は無効になりません。

![CYP201](assets/fr/027.webp)

- `SIGHASH_SINGLE` (`0x03`): 署名はすべての入力と、署名された入力のインデックスに対応する単一の出力をカバーします。例えば、入力#0の*scriptPubKey*をアンロックする署名は、出力#0もカバーします。署名は他のすべての入力も保護し、これらはもはや変更することができません。しかし、出力#0（それによって唯一カバーされる出力）が変更されない限り、誰でも追加の出力を追加することができ、署名を無効にすることはありません。
  ![CYP201](assets/fr/028.webp)

これら3つの基本的なsighashフラグに加えて、修飾子`SIGHASH_ANYONECANPAY` (`0x80`)もあります。この修飾子は基本的なsighashフラグと組み合わせて、3つの新しいsighashフラグを作成することができます：

- `SIGHASH_ALL | SIGHASH_ANYONECANPAY` (`0x81`): 署名は単一の入力をカバーし、トランザクションのすべての出力を含みます。この組み合わせたsighashフラグは、例えばクラウドファンディングトランザクションの作成を可能にします。主催者は自分のアドレスと目標額を出力に準備し、各投資家はその出力を資金提供するために入力を追加することができます。出力を満たすために十分な資金が入力に集まったら、トランザクションをブロードキャストすることができます。

![CYP201](assets/fr/029.webp)

- `SIGHASH_NONE | SIGHASH_ANYONECANPAY` (`0x82`): 署名は単一の入力をカバーし、どの出力にもコミットしません。

![CYP201](assets/fr/030.webp)

- `SIGHASH_SINGLE | SIGHASH_ANYONECANPAY` (`0x83`): この署名は単一の入力と、この入力と同じインデックスを持つ出力をカバーします。例えば、入力＃3の*scriptPubKey*を解除する署名は、出力＃3もカバーします。トランザクションの残りの部分は、他の入力と他の出力の両方について変更可能です。
  ![CYP201](assets/fr/031.webp)

### 新しいSighashフラグを追加するプロジェクト

現在（2024年）、Bitcoinで使用可能なsighashフラグは前のセクションで紹介されたもののみです。しかし、新しいsighashフラグの追加を検討しているプロジェクトもあります。例えば、Christian DeckerとAnthony Townsによって提案されたBIP118は、2つの新しいsighashフラグ`SIGHASH_ANYPREVOUT`と`SIGHASH_ANYPREVOUTANYSCRIPT`（_AnyPrevOut = "Any Previous Output"_）を導入します。

これら2つのsighashフラグは、Bitcoinに追加の可能性を提供します：トランザクションの特定の入力をカバーしない署名を作成すること。

![CYP201](assets/fr/032.webp)

このアイデアは元々、Joseph PoonとThaddeus DryjaによるLightning White Paperで提案されました。改名される前、このsighashフラグは`SIGHASH_NOINPUT`と呼ばれていました。
このsighashフラグがBitcoinに統合されると、covenantsの使用を可能にするだけでなく、Eltooの実装にも必須の前提条件となります。Eltooは、UTXOの所有権を共同で管理する方法を定義する、第二層の一般的なプロトコルです。Eltooは、Lightningチャネルの状態を交渉するメカニズムに関連する問題を解決するために特別に設計されました。

Lightning Networkについての知識を深めるために、CYP201コースの後には、Fanis MichalakisによるLNP201コースを強くお勧めします。このコースでは、トピックについて詳しくカバーしています：

https://planb.network/courses/lnp201

次のパートでは、Bitcoinウォレットの基礎となるニーモニックフレーズの仕組みを発見しましょう。

# ニーモニックフレーズ

<partId>4070af16-c8a2-58b5-9871-a22c86c07458</partId>

## Bitcoinウォレットの進化

<chapterId>9d9acd5d-a0e5-5dfd-b544-f043fae8840f</chapterId>

ハッシュ関数とデジタル署名の仕組みを探求した今、Bitcoinウォレットの機能について学ぶことができます。目標は、Bitcoin上のウォレットがどのように構築され、どのように分解され、構成する情報が何に使用されるかを想像することです。ウォレットのメカニズムを理解することで、セキュリティとプライバシーの面でBitcoinの使用を改善できます。

技術的な詳細に入る前に、「Bitcoinウォレット」とは何か、その有用性を理解することが不可欠です。

### Bitcoinウォレットとは？

従来のウォレットが紙幣や硬貨を収納できるのに対し、Bitcoinウォレットはビットコインをそのものとして「含む」わけではありません。実際、ビットコインは物理的またはデジタルな形で存在するわけではなく、**UTXOs**（_Unspent Transaction Output_）の形でシステム内に表される勘定単位によって表されます。
UTXOsは、さまざまなサイズのビットコインの断片を表し、それらの*scriptPubKey*が満たされることで支出することができます。ビットコインを使うためには、ユーザーは自分のUTXOに関連付けられた*scriptPubKey*を解除する*scriptSig*を提供する必要があります。この証明は、通常、*scriptPubKey*に存在する公開鍵に対応する秘密鍵から生成されるデジタル署名を通じて行われます。したがって、ユーザーが保護する必要がある重要な要素は秘密鍵です。ビットコインウォレットの役割は、これらの秘密鍵を安全に管理することに正確にあります。実際には、その役割は伝統的な意味でのウォレットよりもキーチェーンに近いものです。

### JBOKウォレット（_Just a Bunch Of Keys_）

ビットコインで最初に使用されたウォレットはJBOK（_Just a Bunch Of Keys_）ウォレットで、互いに独立してプライベートに生成されたキーをまとめていました。これらのウォレットは、各秘密鍵がユニークなビットコイン受信アドレスを解除できるシンプルなモデルで動作しました。

![CYP201](assets/fr/033.webp)

複数の秘密鍵を使用したい場合は、デバイスの問題でウォレットにアクセスできなくなった場合に備えて、同じ数のバックアップを作成する必要がありました。単一の秘密鍵を使用する場合、このウォレット構造で十分かもしれませんが、単一のバックアップで十分です。しかし、これには問題があります：ビットコインでは、常に同じ秘密鍵を使用することは強く勧められていません。実際、秘密鍵はユニークなアドレスに関連付けられており、ビットコイン受信アドレスは通常、一度限りの使用を目的として設計されています。資金を受け取るたびに、新しい空白のアドレスを生成する必要があります。

この制約は、ビットコインのプライバシーモデルから生じます。同じアドレスを再利用することで、外部の観察者が私のビットコイン取引をすべて追跡しやすくなります。そのため、受信アドレスの再利用は強く discouraged されます。しかし、複数のアドレスを持ち、取引を公に分けるためには、複数の秘密鍵を管理する必要があります。JBOKウォレットの場合、これは新しいキーペアごとに多くのバックアップを作成することを意味し、これはユーザーにとってすぐに複雑で維持が困難なタスクになる可能性があります。

ビットコインのプライバシーモデルについてさらに学び、プライバシーを保護する方法を発見するために、Plan ₿ NetworkのBTC204コースをフォローすることもお勧めします：

https://planb.network/courses/btc204

### HDウォレット（_Hierarchical Deterministic_）

JBOKウォレットの制限に対処するために、その後、新しいウォレット構造が利用されました。2012年に、Pieter WuilleはBIP32を導入し、階層的決定性ウォレットを改善しました。HDウォレットの原理は、シードと呼ばれる単一の情報源からすべての秘密鍵を決定的かつ階層的に導出することです。このシードはウォレットが作成されたときにランダムに生成され、ウォレットのすべての秘密鍵を再作成するためのユニークなバックアップとなります。したがって、ユーザーは非常に多くの秘密鍵を生成してアドレスの再利用を避け、プライバシーを保護することができ、シードを介してウォレットの単一のバックアップのみを作成する必要があります。
![CYP201](assets/fr/034.webp)

HDウォレットでは、キーの導出は階層構造に従って実行され、キーを導出サブスペースに整理し、さらに細分化して資金管理と異なるウォレットソフトウェア間の相互運用を容易にします。現在、この標準はビットコインユーザーの大多数によって採用されています。この理由から、次の章で詳しく検討します。

### BIP39標準：ニーモニックフレーズ

BIP32に加えて、BIP39はシードフォーマットをニーモニックフレーズとして標準化し、ユーザーによるバックアップと可読性を容易にします。ニーモニックフレーズ、または回復フレーズや24語フレーズとも呼ばれるものは、事前に定義されたリストから選ばれた単語の連続で、ウォレットのシードを安全にエンコードします。

ニーモニックフレーズは、ユーザーのバックアップを大幅に簡素化します。デバイスの紛失、損傷、または盗難が発生した場合でも、このニーモニックフレーズを知っていれば、ウォレットを再作成し、それによって保護されているすべての資金へのアクセスを回復することができます。

今後の章では、HDウォレットの内部動作、キー派生メカニズム、および可能な階層構造について探求します。これにより、Bitcoin上の資金のセキュリティの基礎となる暗号学的基盤をより深く理解できるようになります。そして次の章では、ウォレットの基盤となるエントロピーの役割を発見しましょう。

## エントロピーと乱数

<chapterId>b43c715d-affb-56d8-a697-ad5bc2fffd63</chapterId>
現代のHDウォレット（決定論的かつ階層的）は、"エントロピー"と呼ばれる単一の初期情報に依存して、ウォレットキーの全セットを決定論的に生成します。このエントロピーは擬似乱数であり、そのカオスのレベルが部分的にウォレットのセキュリティを決定します。

### エントロピーの定義

暗号学および情報の文脈において、エントロピーはデータソースまたはランダムプロセスに関連する不確実性または予測不可能性の定量的尺度です。特にキーと乱数の生成において、暗号システムのセキュリティに重要な役割を果たします。高いエントロピーは、生成されたキーが十分に予測不可能であり、攻撃者がキーを推測するために可能なすべての組み合わせを試みるブルートフォース攻撃に対して抵抗力があることを保証します。

Bitcoinの文脈では、エントロピーはシードを生成するために使用されます。決定論的かつ階層的なウォレットを作成する際、ニーモニックフレーズの構築はエントロピーのソースから派生したランダムナンバーから行われます。その後、このフレーズを使用して、UTXOs上の支出条件を作成するために、決定論的かつ階層的な方法で複数のプライベートキーを生成します。

### エントロピーの生成方法

HDウォレットの初期エントロピーは一般的に128ビットまたは256ビットで、以下の通りです：

- **128ビットのエントロピー**は**12語**のニーモニックフレーズに対応します；
- **256ビットのエントロピー**は**24語**のニーモニックフレーズに対応します。

ほとんどの場合、このランダムナンバーはウォレットソフトウェアによってPRNG（_擬似乱数生成器_）を使用して自動的に生成されます。PRNGは、初期状態から数列を生成するアルゴリズムのカテゴリーで、実際の乱数ではないものの、乱数の特性に近い特性を持っています。良いPRNGは、出力の一様性、予測不可能性、予測攻撃に対する抵抗力などの特性を持つ必要があります。真の乱数生成器（TRNG）とは異なり、PRNGは決定論的で再現可能です。

![CYP201](assets/fr/035.webp)

代替手段として、手動でエントロピーを生成することも可能ですが、これはより良い制御を提供する一方で、はるかにリスクが高いです。HDウォレットのエントロピーを自分で生成することは強くお勧めしません。

次の章では、ランダムナンバーから12語または24語のニーモニックフレーズに至るプロセスについて見ていきます。

## ニーモニックフレーズ

<chapterId>8f9340c1-e6dc-5557-a2f2-26c9669987d5</chapterId>
ニーモニックフレーズ、または「シードフレーズ」、「リカバリーフレーズ」、「秘密フレーズ」、「24語フレーズ」とも呼ばれるものは、通常12または24の単語で構成される一連のフレーズで、エントロピーから生成されます。これは、HDウォレットのすべての鍵を決定論的に導出するために使用されます。つまり、このフレーズから、ビットコインウォレットのすべての秘密鍵と公開鍵を決定論的に生成し、再現することが可能であり、それによって保護されている資金にアクセスすることができます。ニーモニックフレーズの目的は、ビットコインのバックアップと復元を安全かつ簡単に行う手段を提供することです。これは2013年にBIP39で標準に導入されました。
エントロピーからニーモニックフレーズへの変換方法を一緒に見ていきましょう。

### チェックサム

エントロピーをニーモニックフレーズに変換するには、まずエントロピーの末尾にチェックサム（または「制御合計」）を追加する必要があります。このチェックサムは、偶発的な変更が導入されていないことを確認することでデータの完全性を保証するビットの短いシーケンスです。

チェックサムを計算するには、エントロピーに対してSHA256ハッシュ関数が適用されます（一度だけです。これはビットコインでダブルハッシュの代わりに単一のSHA256ハッシュが使用される稀なケースの一つです）。この操作により、256ビットのハッシュが生成されます。チェックサムはこのハッシュの最初のビットで構成され、その長さは以下の式に従ってエントロピーの長さに依存します：

$$
\text{CS} = \frac{\text{ENT}}{32}
$$

ここで、$\text{ENT}$はエントロピーの長さをビットで表し、$\text{CS}$はチェックサムの長さをビットで表します。

例えば、256ビットのエントロピーの場合、ハッシュの最初の8ビットがチェックサムを形成するために取られます：

$$
\text{CS} = \frac{256}{32} = 8 \text{ bits}
$$

チェックサムが計算されると、エントロピーと連結して拡張ビットシーケンス$\text{ENT} \Vert \text{CS}$（「連結する」とは、端から端までをつなげることを意味します）が得られます。

![CYP201](assets/fr/036.webp)

### エントロピーとニーモニックフレーズの対応関係

ニーモニックフレーズの単語数は、初期エントロピーのサイズに依存します。以下の表に示すように：

- $\text{ENT}$: エントロピーのビットでのサイズ；
- $\text{CS}$: チェックサムのビットでのサイズ；
- $w$: 最終的なニーモニックフレーズの単語数。

$$
\begin{array}{|c|c|c|c|}
\hline
\text{ENT} & \text{CS} & \text{ENT} \Vert \text{CS} & w \\
\hline
128 & 4 & 132 & 12 \\
160 & 5 & 165 & 15 \\
192 & 6 & 198 & 18 \\
224 & 7 & 231 & 21 \\
256 & 8 & 264 & 24 \\
\hline
\end{array}
$$

例えば、256ビットのエントロピーの場合、結果$\text{ENT} \Vert \text{CS}$は264ビットとなり、ニーモニックフレーズは24単語になります。

### バイナリシーケンスをニーモニックフレーズに変換

ビットシーケンス$\text{ENT} \Vert \text{CS}$は、11ビットのセグメントに分割されます。各11ビットセグメントは、10進数に変換されると、0から2047の間の数値に対応し、これは[BIP39によって標準化された2048語のリスト](https://github.com/Planb-Network/bitcoin-educational-content/blob/dev/resources/bet/bip39-wordlist/assets/BIP39-WORDLIST.pdf)の中の単語の位置を指定します。

![CYP201](assets/fr/037.webp)
たとえば、128ビットのエントロピーの場合、チェックサムは4ビットで、したがって合計シーケンスは132ビットになります。これは11ビットの12セグメントに分割されます（オレンジ色のビットはチェックサムを指定します）：
![CYP201](assets/fr/038.webp)

各セグメントは、リスト内の単語を表す10進数に変換されます。たとえば、バイナリセグメント`01011010001`は10進数で`721`に相当します。リストのインデックス（0ではなく1から始まる）に合わせて1を加えると、これはリスト内の"*focus*"に相当する単語ランク`722`を与えます。

![CYP201](assets/fr/039.webp)

この対応関係は、12語のフレーズを得るために12のセグメントそれぞれに対して繰り返されます。

![CYP201](assets/fr/040.webp)

### BIP39単語リストの特徴

BIP39単語リストの特徴の一つは、どの単語も同じ順序で同じ最初の4文字を別の単語と共有しないことです。これは、各単語の最初の4文字のみを記録することで、ニーモニックフレーズを保存するのに十分であることを意味します。これは、特に金属サポートに刻印したい人にとって、スペースを節約するのに興味深いかもしれません。

この2048語のリストは、いくつかの言語で存在します。これらは単純な翻訳ではなく、各言語に対して異なる単語です。しかし、ウォレットソフトウェアでは他の言語のバージョンが一般的にサポートされていないため、英語版を使用することを強くお勧めします。

### ニーモニックフレーズの長さをどう選ぶか？
ニーモニックフレーズの最適な長さを決定するには、それが提供する実際のセキュリティを考慮する必要があります。12語のフレーズは128ビットのセキュリティを保証し、24語のフレーズは256ビットを提供します。

しかし、このフレーズレベルのセキュリティの違いは、このフレーズから派生したプライベートキーが128ビットのセキュリティのみから恩恵を受けるため、ビットコインウォレットの全体的なセキュリティを改善しません。実際、以前に見たように、ビットコインのプライベートキーは、$1$から$n-1$の間のランダムな数（またはランダムソースから派生した）から生成されます。ここで、$n$はsecp256k1曲線の生成点$G$の順序を表し、$2^{256}$よりわずかに小さい数です。したがって、これらのプライベートキーは256ビットのセキュリティを提供すると思われるかもしれません。しかし、そのセキュリティは、関連する公開キーからプライベートキーを見つける難しさにあります。この難しさは、楕円曲線上の離散対数問題（*ECDLP*）の数学的問題によって確立されています。この問題を解決するための最もよく知られたアルゴリズムは、ポラードのロー（rho）アルゴリズムであり、キーを破るために必要な操作の数をそのサイズの平方根に減らします。

ビットコインで使用される256ビットキーの場合、ポラードのロー（rho）アルゴリズムは複雑さを$2^{128}$操作に減らします：


$$

O(\sqrt{2^{256}}) = O(2^{128})

$$

したがって、ビットコインで使用されるプライベートキーは128ビットのセキュリティを提供すると考えられています。

その結果、24語のフレーズを選択しても、派生したキーが128ビットのセキュリティしか提供しない場合、ウォレットに追加の保護を提供することはありません。この原則を説明するために、古い木製のドアと強化ドアのある家を想像してみてください。侵入の場合、強化ドアは無用であり、侵入者は木製のドアを通ってしまいます。ここでも同様の状況があります。
128ビットのセキュリティを提供する12語のフレーズは、現在、ビットコインをあらゆる盗難の試みから保護するために十分です。デジタル署名アルゴリズムがより大きなキーを使用するように変更されたり、ECDLP以外の数学的問題に依存するようにならない限り、24語のフレーズは余分なものです。さらに、フレーズが長くなると、バックアップ中の紛失リスクが増加します：半分の長さのバックアップは常に管理が容易です。
テスト用ニーモニックフレーズを手動で生成する方法を具体的に学ぶために、このチュートリアルを見てみることをお勧めします：

https://planb.network/tutorials/wallet/backup/generate-mnemonic-phrase-47507d90-e6af-4cac-b01b-01a14d7a8228
このニーモニックフレーズからウォレットの派生を続ける前に、次の章でBIP39パスフレーズについて紹介します。これは派生プロセスで役割を果たし、ニーモニックフレーズと同じレベルにあります。
## パスフレーズ
<chapterId>6a51b397-f3b5-5084-b151-cef94bc9b93f</chapterId>

見てきたように、HDウォレットは通常12語または24語からなるニーモニックフレーズから生成されます。このフレーズは非常に重要で、物理的なデバイス（例えばハードウェアウォレットなど）が失われた場合にウォレットのすべてのキーを復元することを可能にします。しかし、これは単一の障害点を構成します。なぜなら、それが侵害された場合、攻撃者はすべてのビットコインを盗むことができるからです。ここでBIP39パスフレーズが登場します。

### BIP39パスフレーズとは何ですか？

パスフレーズは、ウォレットのセキュリティを強化するためにニーモニックフレーズに追加されるキー派生プロセスで自由に選択できるオプションのパスワードです。

注意してください、パスフレーズはハードウェアウォレットのPINコードやコンピューター上のウォレットへのアクセスを解除するために使用されるパスワードと混同してはいけません。これらの要素とは異なり、パスフレーズはウォレットのキーの派生において役割を果たします。**これは、それなしではビットコインを回復することができないことを意味します。**

パスフレーズはニーモニックフレーズと連携して動作し、キーが生成されるシードを変更します。したがって、誰かがあなたの12語または24語のフレーズを入手しても、パスフレーズがなければ資金にアクセスすることはできません。パスフレーズを使用することは、異なるキーを持つ新しいウォレットを基本的に作成します。パスフレーズを（わずかに）変更すると、異なるウォレットが生成されます。

![CYP201](assets/fr/041.webp)

### なぜパスフレーズを使用すべきですか？

パスフレーズは任意であり、ユーザーが選択した任意の文字の組み合わせであるため、いくつかの利点を提供します。まず、ニーモニックフレーズの妥協に関連するすべてのリスクを、資金へのアクセスに第二の要素を要求することで減らします（強盗、自宅へのアクセスなど）。

次に、物理的な制約に直面して資金を盗むために、デコイウォレットを戦略的に作成するために使用できます。このシナリオでは、パスフレーズを含まないウォレットに少量のビットコインを入れておき、潜在的な攻撃者を満足させることが考えられます。一方、隠されたウォレットは同じニーモニックフレーズを使用していますが、追加のパスフレーズで保護されています。
最後に、HDウォレットのシードの生成のランダム性を制御したい場合に、パスフレーズの使用が興味深いです。
### 良いパスフレーズを選ぶには？

パスフレーズが効果的であるためには、十分に長くランダムでなければなりません。強力なパスワードと同様に、できるだけ長くランダムなパスフレーズを選択し、文字、数字、記号の多様性を持たせて、どんなブルートフォース攻撃も不可能にすることをお勧めします。
これらのパスフレーズを適切に保存することも重要です。ニーモニックフレーズと同じようにです。**これを失うと、あなたのビットコインへのアクセスを失うことを意味します**。心の中だけで覚えておくことは、損失のリスクを不合理に高めるため、強く勧められません。理想的なのは、ニーモニックフレーズとは別の物理的媒体（紙や金属）にそれを書き留めることです。このバックアップは、ニーモニックフレーズが保存されている場所とは異なる場所に明らかに保管されなければなりません。これは、同時に両方が危険にさらされるのを防ぐためです。
![CYP201](assets/fr/042.webp)

次のセクションでは、ウォレットの基盤となるこれら2つの要素 — ニーモニックフレーズとパスフレーズ — が、あなたのUTXOsをロックする*scriptPubKey*で使用されるキーペアを導出するためにどのように使用されるかを発見します。

# ビットコインウォレットの作成
<partId>9c25e767-7eae-50b8-8c5f-679d8fc83bab</partId>

## シードとマスターキーの作成
<chapterId>63093760-2010-5691-8d0e-9a04732ae557</chapterId>

ニーモニックフレーズとオプションのパスフレーズが生成されると、ビットコインHDウォレットの導出プロセスを開始できます。ニーモニックフレーズは最初にシードに変換され、これがウォレットのすべてのキーの基盤を構成します。

![CYP201](assets/fr/043.webp)

### HDウォレットのシード

BIP39標準は、シードを512ビットのシーケンスとして定義し、これがHDウォレットのすべてのキーの導出の出発点として機能します。シードは、ニーモニックフレーズと可能なパスフレーズから、**PBKDF2**アルゴリズム（*Password-Based Key Derivation Function 2*）を使用して導出されます。これについては、第3.3章で既に議論しました。この導出関数では、以下のパラメータを使用します：

- $m$ : ニーモニックフレーズ；
- $p$ : シードのセキュリティを強化するためにユーザーが選択したオプションのパスフレーズ。パスフレーズがない場合、このフィールドは空のままです；
- $\text{PBKDF2}$ : $\text{HMAC-SHA512}$と$2048$の繰り返しを持つ導出関数；
- $s$: 512ビットのウォレットシード。
ニーモニックフレーズの長さが選択された場合（132ビットまたは264ビット）、PBKDF2関数は常に512ビットの出力を生成し、したがってシードは常にこのサイズになります。

### PBKDF2を使用したシードの導出スキーム

以下の方程式は、ニーモニックフレーズとパスフレーズからシードを導出することを示しています：


$$

s = \text{PBKDF2}_{\text{HMAC-SHA512}}(m, p, 2048)

$$

![CYP201](assets/fr/044.webp)

したがって、シードの値はニーモニックフレーズとパスフレーズの値によって影響を受けます。パスフレーズを変更すると、異なるシードが得られます。しかし、同じニーモニックフレーズとパスフレーズを使用すると、PBKDF2が決定論的関数であるため、常に同じシードが生成されます。これにより、バックアップを通じて同じキーペアを取得できることが保証されます。

**注記：** 一般的な言葉では、「シード」という用語は、言語の誤用により、しばしばニーモニックフレーズを指します。実際、パスフレーズがない場合、一方は単に他方のエンコーディングに過ぎません。しかし、私たちが見てきたように、ウォレットの技術的な現実では、シードとニーモニックフレーズは確かに2つの異なる要素です。

これでシードを手に入れたので、ビットコインウォレットの導出を続けることができます。
### マスターキーとマスターチェーンコード
シードが取得されたら、HDウォレットを導出する次のステップは、マスタープライベートキーとマスターチェーンコードを計算することです。これらは私たちのウォレットの深さ0を表します。

マスタープライベートキーとマスターチェーンコードを取得するために、固定キー「*Bitcoin Seed*」を使用してシードにHMAC-SHA512関数が適用されます。このキーはすべてのBitcoinユーザーに共通です。この定数は、キー導出がBitcoinに特有であることを保証するために選ばれます。ここに要素があります：
- $\text{HMAC-SHA512}$: 導出関数；
- $s$: 512ビットのウォレットシード；
- $\text{"Bitcoin Seed"}$: すべてのBitcoinウォレットに共通の導出定数。


$$

\text{output} = \text{HMAC-SHA512}(\text{"Bitcoin Seed"}, s)

$$

この関数の出力はしたがって512ビットです。それから2つの部分に分けられます：
- 左の256ビットが**マスタープライベートキー**を形成します；
- 右の256ビットが**マスターチェーンコード**を形成します。
数学的に、これら二つの値は以下のように表されます。$k_M$がマスタープライベートキー、$C_M$がマスターチェーンコードです：
$$

k_M = \text{HMAC-SHA512}(\text{"Bitcoin Seed"}, s)_{[:256]}

$$


$$

C_M = \text{HMAC-SHA512}(\text{"Bitcoin Seed"}, s)_{[256:]}

$$

![CYP201](assets/fr/045.webp)

### マスターキーとチェーンコードの役割

マスタープライベートキーは親キーと見なされ、そこからすべての派生プライベートキー（子、孫、ひ孫など）が生成されます。それは導出の階層構造におけるゼロレベルを表します。

一方、マスターチェーンコードは、子供たちのキー導出プロセスに追加のエントロピー源を導入し、特定の潜在的な攻撃に対抗するために使用されます。さらに、HDウォレットでは、各キーペアにはそれぞれ固有のチェーンコードが関連付けられており、このペアから子キーを導出するためにも使用されますが、これについては次の章で詳しく説明します。

HDウォレットの導出を次の要素で続ける前に、次の章でマスターキーとしばしば混同される拡張キーについて紹介したいと思います。それらがどのように構築され、Bitcoinウォレットでどのような役割を果たすかを見ていきます。

## 拡張キー
<chapterId>8dcffce1-31bd-5e0b-965b-735f5f9e4602</chapterId>

拡張キーは単純にキー（プライベートまたはパブリック）とそれに関連するチェーンコードの連結です。このチェーンコードは、親キーから子キーを導出するために不可欠ですが、次の章でこのプロセスをより正確に探求します。これらの拡張キーによって、子キーを導出するために必要なすべての情報を集約し、HDウォレット内のアカウント管理を簡素化することができます。

![CYP201](assets/fr/046.webp)

拡張キーは二つの部分から構成されます：
- プライベートまたはパブリックキーとそれに関連するチェーンコードを含むペイロード；
- ソフトウェア間の相互運用性を容易にし、ユーザーの理解を向上させるためのさまざまな情報を含むメタデータ。

### 拡張キーの仕組み
拡張キーにプライベートキーが含まれている場合、それは拡張プライベートキーとして参照されます。これは、`prv`という言及を含む接頭辞によって認識されます。プライベートキーに加えて、拡張プライベートキーには関連するチェーンコードも含まれています。このタイプの拡張キーを使用すると、すべてのタイプの子プライベートキーを導出することが可能であり、したがって楕円曲線上の点の加算と倍加により、子パブリックキーの全体も導出することができます。

拡張キーがプライベートキーではなく、代わりにパブリックキーを含む場合、それは拡張パブリックキーとして参照されます。これは、`pub`という言及を含む接頭辞によって認識されます。明らかに、キーに加えて、それは関連するチェーンコードも含んでいます。拡張プライベートキーとは異なり、拡張パブリックキーは「通常」の子パブリックキーのみを導出することができます（つまり、「ハード化された」子キーを導出することはできません）。次の章で、これらの「通常」と「ハード化された」の修飾子が何を意味するのかを見ていきます。

しかし、いずれにせよ、拡張パブリックキーは子プライベートキーの導出を許可しません。したがって、誰かが`xpub`にアクセスできたとしても、対応するプライベートキーにアクセスできないため、関連する資金を使うことはできません。彼らは関連するトランザクションを観察するために子パブリックキーを導出することのみができます。

以下に、次の表記法を採用します：
- $K_{\text{PAR}}$: 親パブリックキー；
- $k_{\text{PAR}}$: 親プライベートキー；
- $C_{\text{PAR}}$: 親チェーンコード；
- $C_{\text{CHD}}$: 子チェーンコード；
- $K_{\text{CHD}}^n$: 通常の子パブリックキー；
- $k_{\text{CHD}}^n$: 通常の子プライベートキー；
- $K_{\text{CHD}}^h$: ハード化された子パブリックキー；
- $k_{\text{CHD}}^h$: ハード化された子プライベートキー。

![CYP201](assets/fr/047.webp)

### 拡張キーの構築

拡張キーは以下のように構成されます：
- **バージョン**: キーの性質を識別するバージョンコード（`xprv`、`xpub`、`yprv`、`ypub`など）。この章の終わりに、文字`x`、`y`、`z`が何に対応するかを見ていきます。
- **深さ**: HDウォレット内のマスターキーに対する階層レベル（マスターキーの場合は0）。
- **親フィンガープリント**: ペイロードに存在するキーを導出するために使用された親パブリックキーのHASH160ハッシュの最初の4バイト。
- **インデックス番号**: 同じ親キーを持つ同じ導出レベルのすべてのキーの中で、子キーの識別子。
- **チェーンコード**: 子キーを導出するためのユニークな32バイトコード。
- **キー**: プライベートキー（サイズのために1バイトで接頭辞付き）またはパブリックキー。
- **チェックサム**: HASH256関数（二重SHA256）で計算されたチェックサムも追加され、これにより、その送信または保存中に拡張キーの完全性を検証することができます。

したがって、拡張キーの完全な形式はチェックサムなしで78バイト、チェックサムを含むと82バイトです。それからBase58に変換され、ユーザーによって容易に読み取れる表現が生成されます。Base58形式は、*SegWit*以前の*Legacy*受信アドレスに使用されるのと同じです。

| 要素           | 説明                                                                                                        | サイズ      |
| ----------------- | ------------------------------------------------------------------------------------------------------------------ | --------- |
| Version           | 鍵が公開鍵（`xpub`、`ypub`）か秘密鍵（`xprv`、`zprv`）であるか、および拡張鍵のバージョンを示します | 4バイト   |
| Depth             | マスターキーに対する階層内のレベル                                                                                  | 1バイト    |
| Parent Fingerprint| 親公開鍵のHASH160の最初の4バイト                                                                                    | 4バイト   |
| Index Number      | 子供たちの順序における鍵の位置                                                                                      | 4バイト   |
| Chain Code        | 子鍵を導出するために使用されます                                                                                    | 32バイト  |
| Key               | 秘密鍵（1バイトの接頭辞付き）または公開鍵                                                                          | 33バイト  |
| Checksum          | 整合性を検証するためのチェックサム                                                                                  | 4バイト   |

秘密鍵にのみ1バイトが追加されるのは、圧縮公開鍵が秘密鍵よりも1バイト長いためです。この追加バイトは、`0x00`として秘密鍵の始めに追加され、公開鍵であれ秘密鍵であれ、拡張鍵のペイロードが同じ長さになるようにサイズを均等にします。

### 拡張鍵の接頭辞
先ほど見たように、拡張鍵には拡張鍵のバージョンとその性質の両方を示す接頭辞が含まれています。表記`pub`は、それが拡張公開鍵を指すことを示し、表記`prv`は拡張秘密鍵を指します。拡張鍵の基底に追加される文字は、Legacy、SegWit v0、SegWit v1など、どの標準に従っているかを示すのに役立ちます。
ここに使用される接頭辞とその意味の要約を示します：

| Base 58 Prefix  | Base 16 Prefix  | Network | Purpose             | Associated Scripts  | Derivation            | Key Type     |
| --------------- | --------------- | ------- | ------------------- | ------------------- | --------------------- | ------------ |
| `xpub`          | `0488b21e`      | Mainnet | Legacy and SegWit V1 | P2PK / P2PKH / P2TR | `m/44'/0'`, `m/86'/0'` | public       |
| `xprv`          | `0488ade4`      | Mainnet | Legacy and SegWit V1 | P2PK / P2PKH / P2TR | `m/44'/0'`, `m/86'/0'` | private      |
| `tpub`          | `043587cf`      | Testnet | Legacy and SegWit V1 | P2PK / P2PKH / P2TR | `m/44'/1'`, `m/86'/1'` | public       |
| `tprv`          | `04358394`      | Testnet | Legacy and SegWit V1 | P2PK / P2PKH / P2TR | `m/44'/1'`, `m/86'/1'` | private      |
| `ypub`          | `049d7cb2`      | Mainnet | Nested SegWit       | P2WPKH in P2SH      | `m/49'/0'`             | public       |
| `yprv`          | `049d7878`      | Mainnet | Nested SegWit       | P2WPKH in P2SH      | `m/49'/0'`             | private      |
| `upub`          | `049d7cb2`      | Testnet | Nested SegWit       | P2WPKH in P2SH      | `m/49'/1'`             | public       |
| `uprv`          | `044a4e28`      | Testnet | Nested SegWit       | P2WPKH in P2SH      | `m/49'/1'`             | private      |
| `zpub`          | `04b24746`      | Mainnet | SegWit V0           | P2WPKH              | `m/84'/0'`             | public       |
| `zprv`          | `04b2430c`      | Mainnet | SegWit V0           | P2WPKH              | `m/84'/0'`             | private      |
| `vpub`          | `045f1cf6`      | Testnet | SegWit V0           | P2WPKH              | `m/84'/1'`             | public       |
| `vprv`          | `045f18bc`      | Testnet | SegWit V0           | P2WPKH              | `m/84'/1'`             | private      |


### 拡張キーの要素の詳細

拡張キーの内部構造をよりよく理解するために、一つの拡張キーを例にとって分解してみましょう。こちらが拡張キーの例です：

- **Base58で**:

```text
xpub6CTNzMUkzpurBWaT4HQoYzLP4uBbGJuWY358Rj7rauiw4rMHCyq3Rfy9w4kyJXJzeFfyrKLUar2rUCukSiDQFa7roTwzjiAhyQAdPLEjqHT
```

- **16進数で**:

```text
0488B21E036D5601AD80000000C605DF9FBD77FD6965BD02B77831EC5C78646AD3ACA14DC3984186F72633A89303772CCB99F4EF346078D167065404EED8A58787DED31BFA479244824DF50658051F067C3A
```

この拡張キーは、いくつかの異なる要素に分解されます：

1. **バージョン**: `0488B21E`

最初の4バイトはバージョンです。ここでは、Mainnet上の拡張公開鍵で、導出目的は*Legacy*または*SegWit v1*に対応しています。

2. **深さ**: `03`

このフィールドは、HDウォレット内のキーの階層レベルを示します。この場合、`03`の深さは、このキーがマスターキーから3レベルの導出下にあることを意味します。

3. **親の指紋**: `6D5601AD`
これらは、親の公開鍵から派生したこの`xpub`のHASH160ハッシュの最初の4バイトです。
4. **インデックス番号**: `80000000`

このインデックスは、親の子供たちの中での鍵の位置を示します。`0x80`のプレフィックスは、鍵が強化された方法で派生されたことを示し、残りがゼロで埋められているため、この鍵が可能な兄弟の中で最初であることを示します。

5. **チェーンコード**: `C605DF9FBD77FD6965BD02B77831EC5C78646AD3ACA14DC3984186F72633A893`
6. **公開鍵**: `03772CCB99F4EF346078D167065404EED8A58787DED31BFA479244824DF5065805`
7. **チェックサム**: `1F067C3A`

チェックサムは、他のすべてのハッシュ（ダブルSHA256）の最初の4バイトに対応します。

この章では、子鍵には2種類の異なるタイプがあることを発見しました。また、これらの子鍵の派生には鍵（プライベートまたは公開）とそのチェーンコードが必要であることも学びました。次の章では、これらの異なるタイプの鍵の性質と、親鍵とチェーンコードからそれらをどのように派生させるかを詳しく調べます。

## 子鍵ペアの派生
<chapterId>61c0807c-845b-5076-ad06-7f395b36adfd</chapterId>

Bitcoin HDウォレットにおける子鍵ペアの派生は、大量の鍵を生成しながらこれらのペアを枝を通じて異なるグループに編成することを可能にする階層構造に依存しています。親ペアから派生した各子ペアは、ビットコインをロックするための*scriptPubKey*に直接使用されるか、さらに多くの子鍵を生成する出発点として使用され、鍵の木を作成するために、これが繰り返されます。

これらの派生はすべて、深さレベル0で最初の親であるマスターキーとマスターチェーンコードから始まります。これらは、あなたのウォレットの鍵の共通の祖先であるアダムとイブのようなものです。

![CYP201](assets/fr/048.webp)

この決定論的な派生の仕組みを探りましょう。

### 子鍵派生の異なるタイプ

前章で簡単に触れたように、子鍵は主に2つのタイプに分かれます：
1. **通常の子鍵** ($k_{\text{CHD}}^n, K_{\text{CHD}}^n$): これらは拡張公開鍵($K_{\text{PAR}}$)、または拡張プライベート鍵($k_{\text{PAR}}$)から、最初に公開鍵を派生させることによって得られます。
2. **強化された子鍵** ($k_{\text{CHD}}^h, K_{\text{CHD}}^h$): これらは拡張プライベート鍵($k_{\text{PAR}}$)からのみ派生可能であり、したがって拡張公開鍵を持つ観察者には見えません。
すべての子キーペアは32ビットの**インデックス**（計算では$i$と名付けられています）によって識別されます。通常のキーのインデックスは$0$から$2^{31}-1$の範囲にあり、強化キーのインデックスは$2^{31}$から$2^{32}-1$の範囲にあります。これらの数値は、導出中に兄弟キーペアを区別するために使用されます。実際、各親キーペアは複数の子キーペアを導出できなければなりません。親キーから同じ計算を系統的に適用した場合、得られるすべての兄弟キーが同一になってしまい、これは望ましくありません。したがって、インデックスは導出計算を変更する変数を導入し、各兄弟ペアを区別できるようにします。特定のプロトコルや導出標準での特定の使用を除き、一般的には最初の子キーをインデックス`0`で、次にインデックス`1`で、というように導出を開始します。
### HMAC-SHA512を用いた導出プロセス

各子キーの導出は、セクション2でハッシュ関数について議論したHMAC-SHA512関数に基づいています。これは2つの入力を取ります：親チェーンコード$C_{\text{PAR}}$と、インデックスと結合された親キー（望まれる子キーのタイプに応じて公開キー$K_{\text{PAR}}$または秘密キー$k_{\text{PAR}}$）です。HMAC-SHA512の出力は512ビットのシーケンスで、2つの部分に分かれています：
- **最初の32バイト**（または$h_1$）は新しい子ペアの計算に使用されます。
- **最後の32バイト**（または$h_2$）は子ペアの新しいチェーンコード$C_{\text{CHD}}$として機能します。

私たちの計算では、HMAC-SHA512関数の出力を$\text{hash}$と表記します。

![CYP201](assets/fr/049.webp)

#### 親秘密キーから子秘密キーを導出する

親秘密キー$k_{\text{PAR}}$から子秘密キー$k_{\text{CHD}}$を導出するには、強化キーまたは通常キーが望まれるかに応じて、2つのシナリオが可能です。

**通常の子キー**（$i < 2^{31}$）の場合、$\text{hash}$の計算は以下の通りです：


$$

\text{hash} = \text{HMAC-SHA512}(C_{\text{PAR}}, G \cdot k_{\text{PAR}} \Vert i)

$$
この計算では、HMAC関数が2つの入力を取ることがわかります：まず、親チェーンコード、次に親秘密キーに関連付けられた公開キーとインデックスの結合です。ここでは通常の子キーを導出するために親公開キーが使用されていますが、強化キーではありません。
これで、32バイトずつ2つの部分に分割される64バイトの$\text{hash}$が得られます：$h_1$と$h_2$：


$$

\text{hash} = h_1 \Vert h_2

$$


$$

h_1 = \text{hash}_{[:32]} \quad, \quad h_2 = \text{hash}_{[32:]}

$$

次に、子秘密キー$k_{\text{CHD}}^n$は以下のように計算されます：


$$

k_{\text{CHD}}^n = \text{parse256}(h_1) + k_{\text{PAR}} \mod n

$$
この計算では、操作 $\text{parse256}(h_1)$ は、$\text{hash}$ の最初の32バイトを256ビット整数として解釈することから成ります。この数値はその後、親の秘密鍵に加えられ、全てが $n$ によってモジュロ演算されます。これは、セクション3で見たデジタル署名における楕円曲線の順序内に留まるためです。したがって、通常の子秘密鍵を導出するには、HMAC-SHA512関数の入力計算の基礎として親の公開鍵が使用されるものの、計算を完了するためには常に親の秘密鍵が必要です。
この子秘密鍵から、ECDSAまたはSchnorrを適用することにより、対応する公開鍵を導出することが可能です。この方法で、完全な鍵のペアを得ることができます。

次に、$\text{hash}$ の第二部分は、単に私たちが導出したばかりの子鍵ペアのチェーンコードとして解釈されます：


$$

C\_{\text{CHD}} = h_2

$$

全体の導出の概念図は以下の通りです：

![CYP201](assets/fr/050.webp)

**ハード化された子鍵** ($i \geq 2^{31}$) の場合、$\text{hash}$ の計算は以下の通りです：


$$

hash = \text{HMAC-SHA512}(C_{\text{PAR}}, 0x00 \Vert k_{\text{PAR}} \Vert i)

$$

この計算では、HMAC関数が2つの入力を取ることがわかります：まず、親のチェーンコード、そして次にインデックスと親の秘密鍵の連結です。ここではハード化された子鍵を導出しようとしているため、親の秘密鍵が使用されます。さらに、鍵の最初に `0x00` と等しいバイトが追加されます。この操作により、その長さが圧縮された公開鍵の長さと一致するようになります。
したがって、私たちは64バイトの $\text{hash}$ を得て、それを32バイトずつ2つの部分 $h_1$ と $h_2$ に分割します：
$$

\text{hash} = h_1 \Vert h_2

$$


$$

h_1 = \text{hash}[:32] \quad, \quad h_2 = \text{hash}[32:]

$$

次に、子秘密鍵 $k_{\text{CHD}}^h$ は以下のように計算されます：


$$

k_{\text{CHD}}^h = \text{parse256}(h_1) + k_{\text{PAR}} \mod n

$$

次に、$\text{hash}$ の第二部分を単に導出したばかりの子鍵ペアのチェーンコードとして解釈します：


$$

C\_{\text{CHD}} = h_2

$$

全体の導出の概念図は以下の通りです：

![CYP201](assets/fr/051.webp)

通常の導出とハード化された導出は同じ方法で機能することがわかりますが、この違いがあります：通常の導出ではHMAC関数への入力として親の公開鍵が使用され、ハード化された導出では親の秘密鍵が使用されます。

#### 親の公開鍵から子の公開鍵を導出する
親の公開キー $K_{\text{PAR}}$ とそれに関連するチェーンコード $C_{\text{PAR}}$、つまり拡張公開キーのみがわかっている場合、通常の（非強化された）子キーに対してのみ、子の公開キー $K_{\text{CHD}}^n$ を導出することが可能です。この原理は、`xpub` (*ウォッチオンリー*)からBitcoinウォレットのアカウントの動きを監視することを特に可能にします。
この計算を実行するために、インデックス $i < 2^{31}$（通常の導出）を使用して $\text{hash}$ を計算します：


$$

\text{hash} = \text{HMAC-SHA512}(C_{\text{PAR}}, K_{\text{PAR}} \Vert i)

$$

この計算では、HMAC関数が2つの入力を取ることがわかります：最初に親のチェーンコード、次にインデックスと親の公開キーの連結です。

したがって、私たちは今、2つの32バイトの部分に分割される64バイトの $hash$ を持っています：$h_1$ と $h_2$：


$$

\text{hash} = h_1 \Vert h_2

$$


$$

h_1 = \text{hash}[:32] \quad, \quad h_2 = \text{hash}[32:]

$$

次に、子の公開キー $K_{\text{CHD}}^n$ は以下のように計算されます：


$$

K_{\text{CHD}}^n = G \cdot \text{parse256}(h_1) + K_{\text{PAR}}

$$
もし $\text{parse256}(h_1) \geq n$（楕円曲線の位数）であるか、または $K_{\text{CHD}}^n$ が無限遠点である場合、導出は無効であり、別のインデックスを選択する必要があります。
この計算では、操作 $\text{parse256}(h_1)$ は $\text{hash}$ の最初の32バイトを256ビット整数として解釈することを含みます。この数値は、生成点 $G$ からの加算と倍加を通じて楕円曲線上の点を計算するために使用されます。この点は、親の公開キーに加えられ、通常の子の公開キーを得るために使用されます。したがって、通常の子の公開キーを導出するためには、親の公開キーと親のチェーンコードのみが必要であり、以前に見た子の秘密キーの計算とは異なり、親の秘密キーはこのプロセスには一切関与しません。

次に、子のチェーンコードは単純に：


$$

C\_{\text{CHD}} = h_2

$$

こちらは全体の導出の概略図です：

![CYP201](assets/fr/052.webp)

### 子の公開キーと秘密キーの対応関係

親の公開キーから導出された通常の子の公開キーが、対応する親の秘密キーから導出された通常の子の秘密キーにどのように対応するかという疑問が生じるかもしれません。このリンクは、楕円曲線の特性によって正確に保証されています。実際、通常の子の公開キーを導出するためには、HMAC-SHA512が同じ方法で適用されますが、その出力は異なる方法で使用されます：
   - **通常の子の秘密キー**：$k_{\text{CHD}}^n = \text{parse256}(h_1) + k_{\text{PAR}} \mod n$
   - **通常の子の公開キー**：$K_{\text{CHD}}^n = G \cdot \text{parse256}(h_1) + K_{\text{PAR}}$
楕円曲線上の加算と倍加演算のおかげで、両方の方法は一貫した結果を生み出します：子プライベートキーから導出された公開キーは、親公開キーから直接導出された子公開キーと同一です。

### 導出タイプの要約

ここに、可能な導出タイプを要約します：

$$
\begin{array}{|c|c|c|c|}
\hline
\rightarrow & \text{PAR} & \text{CHD} & \text{n/h} \\
\hline
k_{\text{PAR}} \rightarrow k_{\text{CHD}} & k_{\text{PAR}} & \{ k_{\text{CHD}}^n, k_{\text{CHD}}^h \} & \{ n, h \} \\
k_{\text{PAR}} \rightarrow K_{\text{CHD}} & k_{\text{PAR}} & \{ K_{\text{CHD}}^n, K_{\text{CHD}}^h \} & \{ n, h \} \\
K_{\text{PAR}} \rightarrow k_{\text{CHD}} & K_{\text{PAR}} & \times & \times \\
K_{\text{PAR}} \rightarrow K_{\text{CHD}} & K_{\text{PAR}} & K_{\text{CHD}}^n & n \\
\hline
\end{array}
$$

要約すると、これまでにHDウォレットの基本要素を作成する方法を学びました：ニーモニックフレーズ、シード、そしてマスターキーとマスターチェーンコード。また、この章で子キーペアを導出する方法も発見しました。次の章では、これらの導出がビットコインウォレットでどのように組織され、*scriptPubKey* と *scriptSig* で使用されるキーペアと受信アドレスを具体的に取得するためにどの構造に従うべきかを探求します。

## ウォレットの構造と導出パス
<chapterId>34e1bbda-67de-5493-b268-1fded8d67689</chapterId>

ビットコインのHDウォレットの階層構造は、さまざまな方法でキーペアを組織することを可能にします。アイデアは、マスタープライベートキーとマスターチェーンコードから、複数の深さレベルを導出することです。追加された各レベルは、親キーペアから子キーペアを導出することに対応します。

時間が経つにつれて、異なるBIPがこれらの導出パスの標準を導入し、異なるソフトウェア間での使用を標準化することを目指しています。したがって、この章では、これらの標準に従ってHDウォレットの各導出レベルの意味を発見します。

### HDウォレットの導出の深さ

導出パスは、マスターキーから子キーを導出するために使用されるインデックスのシーケンスを指します。

**深さ0: マスターキー (BIP32)**

この深さは、ウォレットのマスタープライベートキーとマスターチェーンコードに対応します。これは$m/$の表記で表されます。

**深さ1: 目的 (BIP43)**
目標は、導出の論理的構造を決定します。例えば、P2WPKHアドレスは深さ1で$/84'/$を持ちます（BIP84による）、一方、P2TRアドレスは$/86'/$を持ちます（BIP86による）。この層は、BIP番号に対応するインデックス番号を示すことで、ウォレット間の互換性を容易にします。
言い換えれば、マスターキーとマスターチェーンコードを持っていれば、これらは子キーペアを導出するための親キーペアとして機能します。この導出で使用されるインデックスは、例えばウォレットがSegWit v0タイプのスクリプトを使用することを意図している場合、$/84'/$です。このキーペアはその後、深さ1にあります。その役割はビットコインをロックすることではなく、単に導出階層の中での中継点として機能することです。

**深さ2: 通貨タイプ (BIP44)**

深さ1のキーペアから、新たな導出が行われ、深さ2のキーペアが得られます。この深さにより、同じウォレット内の他の暗号通貨とビットコインアカウントを区別することができます。

各通貨には、マルチカレンシーウォレット間の互換性を保証するために、ユニークなインデックスがあります。例えば、ビットコインの場合、インデックスは$/0'/$（または16進数表記で`0x80000000`）です。通貨インデックスは、強化された導出を保証するために、$2^{31}$から$2^{32}-1$の範囲で選ばれます。

他の例をいくつか挙げると、以下の通貨のインデックスがあります：
- テストネットビットコインのための$1'$（`0x80000001`）;
- ライトコインのための$2'$（`0x80000002`）;
- イーサリアムのための$60'$（`0x8000003c`）...

**深さ3: アカウント (BIP32)**

各ウォレットは、$2^{31}$から番号付けされた複数のアカウントに分割することができ、深さ3では最初のアカウントに対して$/0'/$、2番目に対して$/1'/$などで表されます。一般的に、拡張キー`xpub`に言及する場合、それはこの導出の深さのキーを指します。

この異なるアカウントへの分割は任意です。これは、ユーザーのウォレットの組織を簡素化することを目的としています。実際には、通常、デフォルトで最初のアカウントが使用されることが多いです。しかし、異なる用途のキーペアを明確に区別したい場合には、これが役立つことがあります。例えば、同じシードから完全に異なるキーグループを持つ個人アカウントとプロフェッショナルアカウントを作成することが可能です。
**深さ4: チェーン (BIP32)**
深さ3で定義された各アカウントは、次に2つのチェーンに構造化されます：
- **外部チェーン**：このチェーンでは、いわゆる「公開」アドレスが導出されます。これらの受信アドレスは、外部トランザクション（つまり、あなたに属さないUTXOの消費から発生する）から来るUTXOをロックするために意図されています。簡単に言うと、ビットコインを受け取りたい場合はいつでもこの外部チェーンが使用されます。ウォレットソフトウェアで「*受け取る*」をクリックすると、常に外部チェーンのアドレスが提供されます。このチェーンは、インデックス$/0/$で導出されたキーペアによって表されます。
- **内部チェーン（おつり）**：このチェーンは、あなたに属するUTXOの消費から来るビットコインをロックする受信アドレス、言い換えればおつりアドレスのために予約されています。これはインデックス$/1/$によって識別されます。

**深さ5: アドレスインデックス (BIP32)**
最後に、深さ5はウォレットの導出の最終ステップを表します。技術的には無限に続けることが可能ですが、現在の標準ではここで停止します。この最終深さで、実際にUTXOをロックおよびアンロックするために使用されるキーペアが導出されます。各インデックスは兄弟キーペアを区別することを可能にします：したがって、最初の受信アドレスはインデックス$/0/$を使用し、2番目はインデックス$/1/$を使用し、以降同様です。
![CYP201](assets/fr/053.webp)

### 導出パスの表記法

導出パスは、各レベルをスラッシュ($/$)で区切って書かれます。したがって、各スラッシュは親キーペア($k_{\text{PAR}}$, $K_{\text{PAR}}$, $C_{\text{PAR}}$)から子キーペア($k_{\text{CHD}}$, $K_{\text{CHD}}$, $C_{\text{CHD}}$)への導出を示します。各深さで記載された番号は、そのキーを親から導出するために使用されるインデックスに対応します。インデックスの右側に時々置かれるアポストロフィ($'$)は、強化導出($k_{\text{CHD}}^h$, $K_{\text{CHD}}^h$)を示します。時々、このアポストロフィは$h$に置き換えられます。アポストロフィまたは$h$がない場合、それは通常の導出($k_{\text{CHD}}^n$, $K_{\text{CHD}}^n$)です。
前の章で見たように、強化キーインデックスは$2^{31}$、または16進数で`0x80000000`から始まります。したがって、導出パスでインデックスの後にアポストロフィが続く場合、指定された数値に$2^{31}$を加えて、HMAC-SHA512関数で使用される実際の値を得る必要があります。例えば、導出パスが$/44'/$を指定している場合、実際のインデックスは以下の通りです：
$$

i = 44 + 2^{31} = 2\,147\,483\,692

$$

16進数では、これは`0x8000002C`です。

導出パスの主要な原則を理解したところで、例を見てみましょう！ここにBitcoin受信アドレスのための導出パスがあります：


$$

m / 84' / 0' / 1' / 0 / 7

$$

この例では：
- $84'$はP2WPKH (SegWit v0) 標準を示します；
- $0'$はメインネット上のBitcoin通貨を示します；
- $1'$はウォレット内の2番目のアカウントに対応します；
- $0$はアドレスが外部チェーン上にあることを示します；
- $7$はこのアカウントの8番目の外部アドレスを示します。

### 導出構造の要約

| 深さ | 説明              | 標準例                            |
| ---- | ----------------- | --------------------------------- |
| 0    | マスターキー       | $m/$                              |
| 1    | 目的              | $/86'/$ (P2TR)                    |
| 2    | 通貨              | $/0'/$ (Bitcoin)                  |
| 3    | アカウント        | $/0'/$ (最初のアカウント)          |
| 4    | チェーン          | $/0/$ (外部) または $/1/$ (変更)   |
| 5    | アドレスインデックス | $/0/$ (最初のアドレス)             |
次の章では、Bitcoin Coreで最近導入されたイノベーションである「*output script descriptors*」（アウトプットスクリプト記述子）について学びます。これは、Bitcoinウォレットのバックアップを簡素化するものです。
## Output script descriptors
<chapterId>e4f1c2d3-9b8a-4d3e-8f2a-7b6c5d4e3f2a</chapterId>
ニーモニックフレーズだけでウォレットへのアクセスを回復できるとよく言われますが、実際にはもう少し複雑です。前章では、HDウォレットの導出構造について見てきましたが、このプロセスがかなり複雑であることに気づいたかもしれません。導出パスは、ソフトウェアがユーザーのキーを導出する方向を指示します。しかし、Bitcoinウォレットを回復する際に、これらのパスを知らない場合、ニーモニックフレーズだけでは不十分です。マスターキーとマスターチェーンコードを取得することはできますが、子キーに到達するために使用されたインデックスを知る必要があります。

理論的には、ウォレットのニーモニックフレーズだけでなく、使用するアカウントへのパスも保存する必要があります。実際には、この情報がなくても、標準に従っていれば、子キーに再アクセスすることがよくあります。各標準を一つずつテストすることで、一般的にはビットコインに再アクセスすることが可能です。しかし、これは保証されておらず、特に初心者にとっては特に複雑です。また、スクリプトタイプの多様化とより複雑な構成の出現により、この情報を推測することが難しくなり、このデータをプライベート情報として、ブルートフォースで回復することが困難になります。これが、最近導入され、お気に入りのウォレットソフトウェアに統合され始めているイノベーションの理由です：*output script descriptors*。

### "descriptor"とは何か？

"*output script descriptors*"、または単に"*descriptors*"は、アウトプットスクリプト（*scriptPubKey*）を完全に記述し、特定のスクリプトに関連するトランザクションを追跡するために必要なすべての情報を提供する構造化された表現です。これらは、HDウォレットのキー管理を容易にするために、ウォレット構造と使用されるアドレスタイプの標準化された完全な記述を提供します。

ディスクリプタの主な利点は、ウォレットを復元するために必要なすべての基本情報を回復フレーズに加えて単一の文字列にカプセル化できる能力にあります。関連するニーモニックフレーズとともにディスクリプタを保存することで、階層内の正確な位置を知ることにより、プライベートキーを復元することが可能になります。当初バックアップがより複雑だったマルチシグウォレットの場合、ディスクリプタには各要素の`xpub`が含まれ、問題が発生した場合にアドレスを再生成する可能性を保証します。

### ディスクリプタの構築

ディスクリプタはいくつかの要素から構成されます：
* `pk`（*Pay-to-PubKey*）、`pkh`（*Pay-to-PubKey-Hash*）、`wpkh`（*Pay-to-Witness-PubKey-Hash*）、`sh`（*Pay-to-Script-Hash*）、`wsh`（*Pay-to-Witness-Script-Hash*）、`tr`（*Pay-to-Taproot*）、`multi`（*Multisignature*）、`sortedmulti`（*キーがソートされたMultisignature*）などのスクリプト関数；
* 導出パス、例えば`[d34db33f/44h/0h/0h]`は、導出されたアカウントパスと特定のマスターキーのフィンガープリントを示します；
* 16進数の公開キーや拡張公開キー（`xpub`）など、さまざまな形式のキー；
* ディスクリプタの完全性を検証するための、ハッシュ記号に先行するチェックサム。
たとえば、P2WPKH（SegWit v0）ウォレットの記述子は次のようになります：
```text
wpkh([cdeab12f/84h/0h/0h]xpub6CUGRUonZSQ4TWtTMmzXdrXDtyPWKiKbERr4d5qkSmh5h17C1TjvMt7DJ9Qve4dRxm91CDv6cNfKsq2mK1rMsJKhtRUPZz7MQtp3y6atC1U/<0;1>/*)#jy0l7nr4
```

この記述子では、導出関数`wpkh`はスクリプトタイプ*Pay-to-Witness-Public-Key-Hash*を示しています。それに続いて、以下を含む導出パスがあります：
* `cdeab12f`：マスターキーのフィンガープリント；
* `84h`：BIP84の目的を示し、SegWit v0アドレス用であることを意味します；
* `0h`：メインネット上のBTC通貨であることを示します；
* `0h`：ウォレットで使用される特定のアカウント番号を指します。

記述子には、このウォレットで使用される拡張公開キーも含まれています：

```text
xpub6CUGRUonZSQ4TWtTMmzXdrXDtyPWKiKbERr4d5qkSmh5h17C1TjvMt7DJ9Qve4dRxm91CDv6cNfKsq2mK1rMsJKhtRUPZz7MQtp3y6atC1U
```

次に、表記`/<0;1>/*`は、記述子が外部チェーン（`0`）と内部チェーン（`1`）からアドレスを生成できることを指定し、ワイルドカード（`*`）を使用して複数のアドレスを設定可能な方法で連続して導出できることを可能にします。これは、従来のウォレットソフトウェアでの「ギャップリミット」の管理に似ています。
最後に、`#jy0l7nr4`は記述子の整合性を検証するためのチェックサムを表します。
これで、Bitcoin上のHDウォレットの操作とキーペアの導出プロセスについてすべて理解しました。しかし、最後の章では、秘密鍵と公開鍵の生成に限定しており、受信アドレスの構築には触れていませんでした。これが次の章の正確な主題になります！

## 受信アドレス
<chapterId>ca80a89d-f8da-4e09-8c35-43179b65bced</chapterId>

受信アドレスは、新しく作成されたUTXOをロックするために*scriptPubKey*に埋め込まれる情報の断片です。簡単に言うと、アドレスはビットコインを受け取るために使用されます。前の章で学んだことと関連して、その動作を探りましょう。

### スクリプトにおけるビットコインアドレスの役割

以前説明したように、トランザクションの役割はビットコインの所有権を入力から出力へと移転することです。このプロセスには、UTXOを入力として消費し、新しいUTXOを出力として作成することが含まれます。これらのUTXOは、資金を解除するために必要な条件を定義するスクリプトによって保護されています。
ユーザーがビットコインを受け取る際、送信者はUTXOを作成し、*scriptPubKey*でロックします。このスクリプトには、通常、このUTXOをアンロックするために必要な署名や公開鍵を指定するルールが含まれています。新しいトランザクションでこのUTXOを使用するためには、ユーザーは*scriptSig*を通じて要求された情報を提供する必要があります。*scriptSig*の実行が*scriptPubKey*と組み合わさって"true"または`1`を返す必要があります。この条件が満たされると、UTXOは新しい*scriptPubKey*でロックされた新しいUTXOを作成するために使用できます。そして、これが続きます。
![CYP201](assets/fr/054.webp)

受信アドレスは正確には*scriptPubKey*に見つかります。しかし、その使用は採用されたスクリプト標準によって異なります。以下は、使用された標準に応じて*scriptPubKey*に含まれる情報と、*scriptPubKey*をアンロックするために*scriptSig*で期待される情報の要約表です。

| 標準               | *scriptPubKey*                                              | *scriptSig*                     | *redeem script*     | *witness*                                |
| ------------------ | ----------------------------------------------------------- | ------------------------------- | ------------------- | ---------------------------------------- |
| P2PK               | `<pubkey> OP_CHECKSIG`                                      | `<signature>`                   |                     |                                          |
| P2PKH              | `OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG` | `<signature> <public key>`      |                     |                                          |
| P2SH               | `OP_HASH160 <scriptHash> OP_EQUAL`                          | `<data pushes> <redeem script>` | 任意のデータ       |                                          |
| P2WPKH             | `0 <pubKeyHash>`                                            |                                 |                     | `<signature> <public key>`               |
| P2WSH              | `0 <witnessScriptHash>`                                     |                                 |                     | `<data pushes> <witness script>`         |
| P2SH-P2WPKH        | `OP_HASH160 <redeemScriptHash> OP_EQUAL`                    | `<redeem script>`               | `0 <pubKeyHash>`    | `<signature> <public key>`               |
| P2SH-P2WSH         | `OP_HASH160 <redeemScriptHash> OP_EQUAL`                    | `<redeem script>`               | `0 <scriptHash>`    | `<data pushes> <witness script>`         |
| P2TR (キーパス)    | `1 <public key>`                                            |                                 |                     | `<signature>`                            |
| P2TR (スクリプトパス) | `1 <public key>`                                            |                                 |                     | `<data pushes> <script> <control block>` |

*出典: Bitcoin Core PR review club, 2021年7月7日 - Gloria Zhao*

スクリプトで使用されるオペコードは情報を操作し、必要に応じて比較やテストを行うよう設計されています。P2PKHスクリプトの例を見てみましょう。以下の通りです：

```text
OP_DUP OP_HASH160 OP_PUSHBYTES_20 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
```

この章で見るように、`<pubKeyHash>`は実際にはUTXOをロックするために使用される受信アドレスのペイロードを表します。この*scriptPubKey*をアンロックするためには、以下を含む*scriptSig*を提供する必要があります：

```text
<signature> <public key>
```
スクリプト言語では、"スタック"は"*LIFO*"（"*Last In, First Out*"、最後に入れたものを最初に出す）データ構造であり、スクリプト実行中に要素を一時的に格納するために使用されます。各スクリプト操作はこのスタックを操作し、要素を追加（*push*）したり削除（*pop*）したりします。スクリプトはこれらのスタックを使用して式を評価し、一時変数を格納し、条件を管理します。
私が例として挙げたスクリプトの実行は、次のプロセスに従います：

- *scriptSig*、*ScriptPubKey*、そしてスタックがあります：

![CYP201](assets/fr/055.webp)

- *scriptSig*がスタックにプッシュされます：

![CYP201](assets/fr/056.webp)

- `OP_DUP`はスタック上の*scriptSig*に提供された公開鍵を複製します：

![CYP201](assets/fr/057.webp)

- `OP_HASH160`はちょうど複製された公開鍵のハッシュを返します：

![CYP201](assets/fr/058.webp)

- `OP_PUSHBYTES_20 <pubKeyHash>`は*scriptPubKey*に含まれるビットコインアドレスをスタックにプッシュします：

![CYP201](assets/fr/059.webp)

- `OP_EQUALVERIFY`は、ハッシュ化された公開鍵が提供された受信アドレスと一致するかを検証します：

![CYP201](assets/fr/060.webp)
`OP_CHECKSIG`は公開鍵を使用して*scriptSig*に含まれる署名をチェックします。このオペコードは、私たちがこのトレーニングのパート3で説明したように、署名検証を基本的に実行します：
![CYP201](assets/fr/061.webp)

- スタックに`1`が残っていれば、そのスクリプトは有効です：

![CYP201](assets/fr/062.webp)

したがって、要約すると、このスクリプトはデジタル署名の助けを借りて、このUTXOの所有権を主張し、それを使用したいユーザーが、このUTXOの作成時に使用された受信アドレスに関連付けられた秘密鍵を実際に持っていることを検証することを可能にします。

### ビットコインアドレスの異なるタイプ

ビットコインの進化に伴い、いくつかの標準スクリプトモデルが追加されました。それぞれが異なるタイプの受信アドレスを使用します。ここでは、現在利用可能な主なスクリプトモデルの概要を紹介します：

**P2PK (*Pay-to-PubKey*)**：

このスクリプトモデルは、ビットコインの最初のバージョンでサトシ・ナカモトによって導入されました。P2PKスクリプトは、生の公開鍵を直接使用してビットコインをロックするため、このモデルでは受信アドレスは使用されません。その構造はシンプルで、公開鍵を含み、資金をアンロックするために対応するデジタル署名が必要です。このスクリプトは"*Legacy*"標準の一部です。

**P2PKH (*Pay-to-PubKey-Hash*)**：

P2PKのように、P2PKHスクリプトもビットコインのローンチ時に導入されました。その前身とは異なり、生の公開鍵を直接使用するのではなく、公開鍵のハッシュを使用してビットコインをロックします。*scriptSig*は、受信アドレスに関連付けられた公開鍵と有効な署名を提供する必要があります。このモデルに対応するアドレスは`1`で始まり、*base58check*でエンコードされます。このスクリプトも"*Legacy*"標準に属します。

**P2SH (*Pay-to-Script-Hash*)**：
2012年にBIP16と共に導入されたP2SHモデルは、任意のスクリプトのハッシュを*scriptPubKey*で使用することを可能にします。このハッシュ化されたスクリプトは、資金の解除条件を含む"*redeemScript*"と呼ばれます。P2SHでロックされたUTXOを使用するには、元の*redeemScript*とそれを検証するために必要なデータを含む*scriptSig*を提供する必要があります。このモデルは、古いマルチシグで特に使用されます。P2SHに関連付けられたアドレスは`3`で始まり、*base58check*でエンコードされます。このスクリプトはまた"*Legacy*"標準に属しています。
**P2WPKH (*Pay-to-Witness-PubKey-Hash*)**:
このスクリプトはP2PKHに似ており、公開鍵のハッシュを使用してビットコインをロックします。しかし、P2PKHとは異なり、*scriptSig*は"*Witness*"と呼ばれる別のセクションに移動されます。これは時々"*scriptWitness*"として言及され、署名と公開鍵のセットを示します。各SegWit入力には独自の*scriptWitness*があり、*scriptWitnesses*の集合はトランザクションの*Witness*フィールドを構成します。署名データのこの移動は、ECDSA署名によるトランザクションの可変性を防ぐことを目的としたSegWitアップデートによって導入された革新です。
P2WPKHアドレスは*bech32*エンコーディングを使用し、常に`bc1q`で始まります。このタイプのスクリプトはバージョン0 SegWit出力に対応しています。

**P2WSH (*Pay-to-Witness-Script-Hash*)**:

P2WSHモデルも2017年8月のSegWitアップデートと共に導入されました。P2SHモデルと同様に、スクリプトのハッシュを使用してビットコインをロックします。署名とスクリプトがトランザクションに組み込まれる方法に主な違いがあります。このタイプのスクリプトでロックされたビットコインを使用するには、受取人は元のスクリプト（P2SHの*redeemScript*に相当する*witnessScript*）と、この*witnessScript*を検証するために必要なデータを提供する必要があります。このメカニズムにより、マルチシグなどのより複雑な支出条件の実装が可能になります。

P2WSHアドレスは*bech32*エンコーディングを使用し、常に`bc1q`で始まります。このスクリプトもバージョン0 SegWit出力に対応しています。

**P2TR (*Pay-to-Taproot*)**:

P2TRモデルは、2021年11月にTaprootの実装と共に導入されました。これは、暗号鍵の集約に関するSchnorrプロトコルと、MAST（*Merkelized Alternative Script Tree*）と呼ばれる代替スクリプトのためのマークルツリーに基づいています。他のタイプのスクリプトとは異なり、支出条件が公開される（受領時または支出時に）のではなく、P2TRは複雑なスクリプトを単一の明らかな公開鍵の背後に隠すことを可能にします。

技術的には、P2TRスクリプトはユニークなSchnorr公開鍵$Q$にビットコインをロックします。このキー$Q$は実際には公開鍵$P$と、*scriptPubKey*のリストのマークルルートから計算される公開鍵$M$の集合です。このタイプのスクリプトでロックされたビットコインは、二つの方法で使用することができます：
- 公開鍵$P$に対する署名を公開する（*key path*）。
- マークルツリーに含まれるスクリプトのいずれかを満たす（*script path*）。
P2TRは、ビットコインを一意の公開鍵でロックすることも、選択した複数のスクリプトでロックすることも、または両方を同時に行うこともできるため、大きな柔軟性を提供します。このマークルツリー構造の利点は、トランザクション中に使用される支出スクリプトのみが明らかにされる一方で、他のすべての代替スクリプトは秘密のままであることです。

![CYP201](assets/fr/063.webp)

P2TRはバージョン1 SegWit出力に対応しており、これはP2TR入力の署名がトランザクションの*Witness*セクションに格納され、*scriptSig*には格納されないことを意味します。P2TRアドレスは*bech32m*エンコーディングを使用し、`bc1p`で始まりますが、構築にハッシュ関数を使用しないため非常にユニークです。実際、それらは公開鍵$Q$を直接表し、メタデータで単純にフォーマットされます。したがって、P2PKに近いスクリプトモデルです。

理論をカバーしたので、実践に移りましょう！次の章では、鍵のペアからSegWit v0アドレスとSegWit v1アドレスの両方を導出することを提案します。

## アドレス導出
<chapterId>3ebdc750-4135-4881-b07e-08965941b93e</chapterId>

例えばHDウォレットの深さ5に位置する鍵のペアから受信アドレスを生成する方法を一緒に探りましょう。このアドレスはその後、ウォレットソフトウェアでUTXOをロックするために使用できます。

アドレスの生成プロセスは採用されたスクリプトモデルに依存するため、P2WPKHでのSegWit v0アドレスの生成とP2TRでのSegWit v1アドレスの生成の2つの特定のケースに焦点を当てましょう。これら2種類のアドレスは、今日の大半の使用をカバーしています。

### 公開鍵の圧縮

マスターキーから適切なインデックスを使用して深さ5までのすべての導出ステップを実行した後、鍵のペア($k$, $K$)を得ます。ここで$K = k \cdot G$です。この公開鍵をそのまま使用してP2PK標準で資金をロックすることは可能ですが、ここではその目的ではありません。代わりに、最初にP2WPKHでアドレスを作成し、次にP2TRで別の例としてアドレスを作成することを目指します。

最初のステップは、公開鍵$K$を圧縮することです。このプロセスをよく理解するために、まず第3部でカバーされたいくつかの基本を思い出しましょう。
Bitcoin上の公開鍵は楕円曲線上の点$K$です。これは$(x, y)$の形で表され、ここで$x$と$y$は点の座標です。非圧縮形式では、この公開鍵は520ビットを測定します：プレフィックス（初期値は`0x04`）に8ビット、$x$座標に256ビット、そして$y$座標に256ビットです。
しかし、楕円曲線はx軸に関して対称性の特性を持っています：与えられた$x$座標に対して、$y$には2つの可能な値、$y$と$-y$があります。これら2点はx軸の両側に位置しています。言い換えれば、$x$を知っていれば、$y$が偶数か奇数かを指定するだけで、曲線上の正確な点を特定するのに十分です。

![CYP201](assets/fr/064.webp)

公開鍵を圧縮するには、$x$のみがエンコードされ、これは256ビットを占め、$y$の偶奇を指定するために接頭辞が追加されます。この方法により、公開鍵のサイズは初期の520ビットではなく264ビットに削減されます。接頭辞`0x02`は$y$が偶数であることを示し、接頭辞`0x03`は$y$が奇数であることを示します。
理解を深めるために、非圧縮表現の生の公開鍵を例に取りましょう：

```text
K = 04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f
```

この鍵を分解すると、以下のようになります：
   - 接頭辞：`04`;
   - $x$：`678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb6`;
   - $y$：`49f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f`

$y$の最後の16進数の文字は`f`です。10進数では、`f = 15`で、これは奇数に相当します。したがって、$y$は奇数であり、これを示すために接頭辞は`0x03`になります。

圧縮された公開鍵は以下のようになります：

```text
K = 03678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb6
```
この操作は、Schnorrを使用するP2TRを除く、ECDSAに基づくすべてのスクリプトモデルに適用されます。Schnorrの場合、第3部で説明されているように、$y$の偶奇を示すための接頭辞を追加することなく、$x$の値のみを保持します。これは、すべての鍵に対して任意に選択された一意の偶奇によって可能になります。これにより、公開鍵のために必要なストレージスペースがわずかに削減されます。
### SegWit v0（bech32）アドレスの導出

圧縮された公開鍵を取得したので、それを使用してSegWit v0受信アドレスを導出することができます。

最初のステップは、圧縮された公開鍵にHASH160ハッシュ関数を適用することです。HASH160は、2つの連続するハッシュ関数、SHA256に続いてRIPEMD160の組み合わせです：


$$

\text{HASH160}(K) = \text{RIPEMD160}(\text{SHA256}(K))

$$

まず、鍵をSHA256を通します：

```text
SHA256(K) = C489EBD66E4103B3C4B5EAFF462B92F5847CA2DCE0825F4997C7CF57DF35BF3A
```

次に、その結果をRIPEMD160を通します：

```text
RIPEMD160(SHA256(K)) = 9F81322CC88622CA4CCB2A52A21E2888727AA535
```
公開鍵の160ビットハッシュを取得しました。これはアドレスのペイロードと呼ばれるものを構成します。このペイロードはアドレスの中心的で最も重要な部分を表します。また、UTXOsをロックするために*scriptPubKey*で使用されます。
しかし、このペイロードを人間がより簡単に使用できるようにするために、メタデータが追加されます。次のステップでは、このハッシュを5ビットのグループに10進数でエンコードします。この10進数変換は、SegWit以降のアドレスで使用される*bech32*への変換に役立ちます。160ビットのバイナリハッシュは、5ビットの32グループに分割されます：

$$
\begin{array}{|c|c|}
\hline
\text{5 bits} & \text{Decimal} \\
\hline
10011 & 19 \\
11110 & 30 \\
00000 & 0 \\
10011 & 19 \\
00100 & 4 \\
01011 & 11 \\
00110 & 6 \\
01000 & 8 \\
10000 & 16 \\
11000 & 24 \\
10001 & 17 \\
01100 & 12 \\
10100 & 20 \\
10011 & 19 \\
00110 & 6 \\
01011 & 11 \\
00101 & 5 \\
01001 & 9 \\
01001 & 9 \\
01010 & 10 \\
00100 & 4 \\
00111 & 7 \\
10001 & 17 \\
01000 & 8 \\
10001 & 17 \\
00001 & 1 \\
11001 & 25 \\
00111 & 7 \\
10101 & 21 \\
00101 & 5 \\
00101 & 5 \\
10101 & 21 \\
\hline
\end{array}
$$
したがって、以下のようになります：

```text
HASH = 19 30 00 19 04 11 06 08 16 24 17 12 20 19 06 11 05 09 09 10 04 07 17 08 17 01 25 07 21 09 09 21
```

ハッシュが5ビットのグループにエンコードされると、アドレスにチェックサムが追加されます。このチェックサムは、アドレスのペイロードが保管または送信中に変更されていないことを確認するために使用されます。例えば、受信アドレスを入力する際に誤字がないかをウォレットソフトウェアが確認することができます。この検証がなければ、誤ったアドレスにビットコインを送信してしまい、関連する公開鍵や秘密鍵を所有していないため、資金の永久的な損失につながる可能性があります。したがって、チェックサムは人為的なエラーに対する保護です。

古いビットコイン*Legacy*アドレスの場合、チェックサムは単純にアドレスハッシュの始まりからHASH256関数を使用して計算されました。SegWitと*bech32*形式の導入により、現在はBCHコード（*Bose, Ray-Chaudhuri, Hocquenghem*）が使用されています。これらのエラー訂正コードは、データシーケンスのエラーを検出し、訂正するために使用されます。軽微な変更があった場合でも、送信された情報が目的地に完全な状態で到着することを保証します。BCHコードは、SSD、DVD、QRコードなど多くの分野で使用されています。例えば、これらのBCHコードのおかげで、部分的に隠されたQRコードでも読み取り、デコードすることができます。

ビットコインの文脈では、BCHコードは*Legacy*アドレスに使用されていた単純なハッシュ関数と比較して、サイズとエラー検出能力の間でより良い妥協を提供します。しかし、ビットコインでは、BCHコードはエラー検出のみに使用され、訂正は行われません。したがって、ウォレットソフトウェアは誤った受信アドレスを示しますが、自動的には訂正しません。この制限は意図的なものです：自動訂正を許可すると、エラー検出能力が低下する可能性があります。

BCHコードでチェックサムを計算するには、いくつかの要素を準備する必要があります：
- **HRP（*Human Readable Part*、人が読める部分）**：Bitcoinメインネットの場合、HRPは`bc`です。
HRPは、各文字を二つの部分に分けて拡張する必要があります：
- HRPの文字をASCIIで取ります：
	- `b`：`01100010`
- `c`：`01100011`
- 最も重要な3ビットと最も重要でない5ビットを抽出します：
  - 最も重要な3ビット：`011`（10進数で3）
  - 最も重要な3ビット：`011`（10進数で3）
  - 最も重要でない5ビット：`00010`（10進数で2）
  - 最も重要でない5ビット：`00011`（10進数で3）

二つの文字の間に`0`のセパレーターを使用すると、HRPの拡張は以下のようになります：

```text
03 03 00 02 03
```

- **ウィットネスバージョン**：SegWitバージョン0の場合、これは`00`です；

- **ペイロード**：公開鍵ハッシュの10進数値；

- **チェックサムのための予約**：シーケンスの最後に6つのゼロ`[0, 0, 0, 0, 0, 0]`を追加します。

チェックサムを計算するためにプログラムに入力する全データは以下の通りです：

```text
HRP = 03 03 00 02 03
SEGWIT v0 = 00
HASH = 19 30 00 19 04 11 06 08 16 24 17 12 20 19 06 11 05 09 09 10 04 07 17 08 17 01 25 07 21 09 09 21
CHECKSUM = 00 00 00 00 00 00

INPUT = 03 03 00 02 03 00 19 30 00 19 04 11 06 08 16 24 17 12 20 19 06 11 05 09 09 10 04 07 17 08 17 01 25 07 21 09 09 21 00 00 00 00 00 00
```

チェックサムの計算はかなり複雑です。これは多項式有限体算術を含みます。ここではこの計算の詳細は省略し、直接結果に移ります。私たちの例では、10進数で得られたチェックサムは以下の通りです：

```text
10 16 11 04 13 18
```

これで、以下の要素を順番に連結して受信アドレスを構築できます：
- **SegWitバージョン**：`00`
- **ペイロード**：公開鍵ハッシュ
- **チェックサム**：前のステップで得られた値（`10 16 11 04 13 18`）

これにより10進数で以下のようになります：

```text
00 19 30 00 19 04 11 06 08 16 24 17 12 20 19 06 11 05 09 09 10 04 07 17 08 17 01 25 07 21 09 09 21 10 16 11 04 13 18
```

その後、各10進数値を以下の変換表を使用して*bech32*文字にマッピングする必要があります：


$$
\begin{array}{|c|c|c|c|c|c|c|c|c|}
\hline
 & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
\hline
+0 & q & p & z & r & y & 9 & x & 8 \\
\hline
+8 & g & f & 2 & t & v & d & w & 0 \\
\hline
+16 & s & 3 & j & n & 5 & 4 & k & h \\
\hline
+24 & c & e & 6 & m & u & a & 7 & l \\
\hline
\end{array}
$$

値を*bech32*文字に変換するには、この表を使用して、最初の列と最初の行にある値を見つけ、それらを合計すると所望の結果が得られるようにします。その後、対応する文字を取得します。例えば、10進数の`19`は、$19 = 16 + 3$であるため、文字`n`に変換されます。
すべての値をマッピングすると、次のアドレスが得られます：

```
qn7qnytxgsc3v5nxt9ff2y83g3pe849942stydj
```

残る作業は、Bitcoinメインネットのアドレスであることを示すHRP`bc`と、セパレータ`1`を追加して、完全な受信アドレスを得ることです：

```
bc1qn7qnytxgsc3v5nxt9ff2y83g3pe849942stydj
```

この*bech32*アルファベットの特徴は、`1`、`b`、`i`、`o`を除くすべての英数字文字を含んでいることで、特に人間による入力や読み取り時に、似た文字間の視覚的な混同を避けるためです。

要約すると、ここに導出プロセスがあります：

![CYP201](assets/fr/065.webp)

これは、鍵のペアからP2WPKH（SegWit v0）受信アドレスを導出する方法です。さあ、P2TR（SegWit v1 / Taproot）アドレスに移り、その生成プロセスを見てみましょう。

### SegWit v1（bech32m）アドレスの導出

Taprootアドレスの生成プロセスは少し異なります。一緒に見ていきましょう！

公開鍵の圧縮のステップから、ECDSAと比較して最初の違いが現れます：Bitcoin上のSchnorrに使用される公開鍵は、その横座標（$x$）のみによって表されます。したがって、プレフィックスはなく、圧縮された鍵は正確に256ビットを測定します。
前章で見たように、P2TRスクリプトは、$Q$と指定されたユニークなSchnorr公開鍵上にビットコインをロックします。この鍵$Q$は、$P$、主な内部公開鍵、および*scriptPubKey*のリストのマークルルートから派生した公開鍵$M$の2つの公開鍵の集合です。このタイプのスクリプトでロックされたビットコインは、2つの方法で使うことができます：

- 公開鍵$P$に対する署名を公開すること（_キーパス_）；
- マークルツリーに含まれるスクリプトのいずれかを満たすこと（_スクリプトパス_）。

実際には、これら2つの鍵は真に「集約された」わけではありません。鍵$P$は、鍵$M$によって変更されます。暗号学において、公開鍵を「調整する」とは、この鍵を「調整」と呼ばれる加算値を適用して変更することを意味します。この操作により、変更された鍵は元の秘密鍵および調整と互換性を保ちながら残ります。技術的には、調整は初期公開鍵に加えられるスカラー値$t$です。$P$が元の公開鍵である場合、調整された鍵は次のようになります：

$$
P' = P + tG
$$

ここで、$G$は使用される楕円曲線の生成元です。この操作により、元の鍵から派生した新しい公開鍵が生成され、その使用を可能にする暗号学的特性を保持します。
代替スクリプトを追加する必要がない場合（*キーパス*を通じてのみ支出する場合）、ウォレットの深さ5にある公開キーのみに基づいてTaprootアドレスを生成できます。この場合、構造の要件を満たすために、*スクリプトパス*用の非支出スクリプトを作成する必要があります。その後、内部公開キー$P$にタグ付きハッシュ関数**`TapTweak`**を適用することによって、調整値$t$が計算されます：

$$
t = \text{H}_{\text{TapTweak}}(P)
$$

ここで：

- **$\text{H}_{\text{TapTweak}}$**は、タグ`TapTweak`でタグ付けされたSHA256ハッシュ関数です。タグ付きハッシュ関数について不明な点がある場合は、3.3章を参照してください。
- $P$は、$x$座標のみを使用して圧縮された256ビット形式で表される内部公開キーです。

その後、Taproot公開キー$Q$は、内部公開キー$P$に調整値$t$を楕円曲線ジェネレータ$G$で乗算したものを加えることによって計算されます：

$$
Q = P + t \cdot G
$$

Taproot公開キー$Q$が得られると、対応する受信アドレスを生成できます。他の形式とは異なり、Taprootアドレスは公開キーのハッシュに基づいて確立されていません。したがって、キー$Q$はそのままの形でアドレスに直接挿入されます。

まず、点$Q$の$x$座標を抽出して圧縮公開キーを取得します。このペイロードには、SegWit v0アドレスと同様に、BCHコードを使用してチェックサムが計算されます。しかし、Taprootアドレスに使用されるプログラムはわずかに異なります。実際、SegWitで*bech32*形式が導入された後、バグが発見されました：アドレスの最後の文字が`p`の場合、この`p`の直前に`q`を挿入または削除してもチェックサムが無効になりません。このバグはSegWit v0には影響しません（サイズ制約のおかげで）、しかし将来的に問題を引き起こす可能性があります。このバグはTaprootアドレス用に修正され、新しい修正された形式は"_bech32m_"と呼ばれます。

Taprootアドレスは、以下の要素を含む*bech32m*形式で$Q$の$x$座標をエンコードすることによって生成されます：

- **HRP（_Human Readable Part_）**：メインのBitcoinネットワークを示すために`bc`；
- **バージョン**：Taproot / SegWit v1を示すために`1`；
- **チェックサム**。

最終的なアドレスは、したがって次の形式になります：

```
bc1p[Qx][checksum]
```

一方、内部公開キー（_スクリプトパス_）で支出するだけでなく、代替スクリプトを追加したい場合、受信アドレスの計算は少し異なります。代替スクリプトのハッシュを調整値の計算に含める必要があります。Taprootでは、各代替スクリプトはマークルツリーの末尾に位置し、「リーフ」と呼ばれます。

異なる代替スクリプトが書かれたら、いくつかのメタデータを伴ってタグ付きハッシュ関数`TapLeaf`を通して個別に渡す必要があります：

$$
\text{h}_{\text{leaf}} = \text{H}_{\text{TapLeaf}} (v \Vert sz \Vert S)
$$

ここで：

- $v$：スクリプトのバージョン番号（Taprootのデフォルトは`0xC0`）；
- $sz$: スクリプトのサイズは _CompactSize_ 形式でエンコードされます；
- $S$: スクリプトです。

異なるスクリプトハッシュ ($\text{h}_{\text{leaf}}$) はまず、辞書順にソートされます。次に、これらをペアで連結し、タグ付きハッシュ関数 `TapBranch` を通して処理します。このプロセスは繰り返し行われ、段階的にマークルツリーを構築します：
$$
\text{h}_{\text{branch}} = \text{H}_{\text{TapBranch}}(\text{h}_{\text{leaf1}} \Vert \text{h}_{\text{leaf2}})
$$

次に、結果を二つずつ連結し、各ステップでタグ付きハッシュ関数 `TapBranch` を通して処理を続け、マークルツリーの根を得ます：

![CYP201](assets/fr/066.webp)

マークルルート $h_{\text{root}}$ が計算されたら、次にtweakを計算します。そのためには、ウォレットの内部公開鍵 $P$ をルート $h_{\text{root}}$ と連結し、結果をタグ付きハッシュ関数 `TapTweak` に通します：

$$
t = \text{H}_{\text{TapTweak}}(P \Vert h_{\text{root}})
$$

最後に、これまでと同様に、Taproot公開鍵 $Q$ は内部公開鍵 $P$ に tweak $t$ と生成点 $G$ の積を加えることで得られます：

$$
Q = P + t \cdot G
$$

その後、アドレスの生成は同じプロセスに従い、公開鍵 $Q$ をペイロードとして使用し、いくつかの追加メタデータを伴います。


これで終わりです！CYP201コースの最後に到達しました。このコースが役立ったと思われる場合、次の評価章で良い評価をしていただけると非常に感謝します。また、愛する人やソーシャルネットワークで共有していただけると嬉しいです。最後に、このコースのディプロマを取得したい場合は、評価章の直後に最終試験を受けることができます。

# 結論

<partId>58111408-b734-54db-9ea7-0d5b67f99f99</partId>

## このコースを評価する

<chapterId>0cd71541-a7fd-53db-b66a-8611b6a28b04</chapterId>
<isCourseReview>true</isCourseReview>

## 最終試験

<chapterId>a53ea27d-0f84-56cd-b37c-a66210a4b31d</chapterId>
<isCourseExam>true</isCourseExam>

## 結論

<chapterId>d291428b-3cfa-5394-930e-4b514be82d5a</chapterId>

CYP201トレーニングの終わりに到達しました。このトレーニングがビットコインの学習に役立ち、日々使用しているHDウォレットの仕組みをより良く理解するのに役立ったことを願っています。このコースを最後まで受講していただき、ありがとうございます！

私の意見では、ウォレットに関するこの知識は基本的なものです。ビットコインの理論的側面と実践的な使用を結びつけるからです。実際、ビットコインを使用する場合、必然的にウォレットソフトウェアを扱うことになります。その内部の仕組みを理解することで、基本的なメカニズム、リスク、潜在的な弱点を把握しながら、効果的なセキュリティ戦略を実装することができます。そうすることで、より安全に、そして自信を持ってビットコインを使用することができます。

まだ評価とコメントをされていない方は、このトレーニングの評価とコメントをお願いします。大変助かります。また、このトレーニングをソーシャルネットワークで共有していただき、できるだけ多くの人々にこの知識を広めていただければと思います。

さらに深く学びを進めるために、Plan ₿ Networkで私が制作した**BTC204**トレーニングを強くお勧めします。これはビットコインのプライバシーに特化しており、重要なテーマを探求します：プライバシーモデルとは何か？チェーン分析はどのように機能するのか？プライバシーを最大化するためにビットコインを最適に使用する方法は？スキルを深めるための論理的な次のステップです！

https://planb.network/courses/btc204

さらに、ビットコインの世界での知識を深めるために、Plan ₿ Networkで利用可能な他のコースもご覧ください：

#### ビットコインコミュニティの作り方を学ぶ

https://planb.network/courses/btc302

#### ライトニングネットワークを発見する

https://planb.network/courses/lnp201

#### オーストリア学派の経済思想を発見する

https://planb.network/courses/eco201

#### ビットコインの起源の歴史を発見する

https://planb.network/courses/his201

#### 時代を通じた自由の進化を発見する

https://planb.network/courses/phi201




